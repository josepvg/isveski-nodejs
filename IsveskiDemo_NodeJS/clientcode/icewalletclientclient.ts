//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

import { BaseClient } from "../common/baseclient";

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export interface IClientDeviceInterfaceClient {

    /**
     * Shows a message
     * @return OK
     */
    showMessage(body: ShowMessageRequest): Promise<void>;

    /**
     * Shows a prompt
     * @return OK
     */
    showPrompt(body: ShowPromptRequest): Promise<ShowPromptResponse>;

    /**
     * Shows a menu
     * @return OK
     */
    showMenu(body: ShowMenuRequest): Promise<ShowMenuResponse>;

    /**
     * Shows multiple choices
     * @return OK
     */
    showMultipleChoice(body: ShowMultipleChoiceRequest): Promise<ShowMultipleChoiceResponse>;

    /**
     * Shows a webpage inside the app, passing the user as a cookie
     * @return OK
     */
    showWebPage(body: ShowWebPageRequest): Promise<ShowWebPageResponse>;

    /**
     * Bioauthenticates the user
     * @return OK
     */
    bioAuthenticate(body: BioAuthenticationRequest): Promise<BioMetricAuthenticationResponse>;

    /**
     * Listens to beacons in the surroundings
     * @return OK
     */
    listenToBeacons(body: ListenToBeaconsRequest): Promise<ListenToBeaconsResponse>;

    /**
     * Shows Qr Code
     * @return OK
     */
    showQrCode(body: ShowQrCodeRequest): Promise<void>;
}

export class ClientDeviceInterfaceClient extends BaseClient implements IClientDeviceInterfaceClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Shows a message
     * @return OK
     */
    showMessage(body: ShowMessageRequest): Promise<void> {
        let url_ = this.baseUrl + "/api/ClientDeviceInterface/ShowMessage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processShowMessage(_response);
        });
    }

    protected processShowMessage(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Shows a prompt
     * @return OK
     */
    showPrompt(body: ShowPromptRequest): Promise<ShowPromptResponse> {
        let url_ = this.baseUrl + "/api/ClientDeviceInterface/ShowPrompt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processShowPrompt(_response);
        });
    }

    protected processShowPrompt(response: Response): Promise<ShowPromptResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShowPromptResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = DeviceException.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShowPromptResponse>(null as any);
    }

    /**
     * Shows a menu
     * @return OK
     */
    showMenu(body: ShowMenuRequest): Promise<ShowMenuResponse> {
        let url_ = this.baseUrl + "/api/ClientDeviceInterface/ShowMenu";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processShowMenu(_response);
        });
    }

    protected processShowMenu(response: Response): Promise<ShowMenuResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShowMenuResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = DeviceException.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShowMenuResponse>(null as any);
    }

    /**
     * Shows multiple choices
     * @return OK
     */
    showMultipleChoice(body: ShowMultipleChoiceRequest): Promise<ShowMultipleChoiceResponse> {
        let url_ = this.baseUrl + "/api/ClientDeviceInterface/ShowMultipleChoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processShowMultipleChoice(_response);
        });
    }

    protected processShowMultipleChoice(response: Response): Promise<ShowMultipleChoiceResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShowMultipleChoiceResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = DeviceException.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShowMultipleChoiceResponse>(null as any);
    }

    /**
     * Shows a webpage inside the app, passing the user as a cookie
     * @return OK
     */
    showWebPage(body: ShowWebPageRequest): Promise<ShowWebPageResponse> {
        let url_ = this.baseUrl + "/api/ClientDeviceInterface/ShowWebPage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processShowWebPage(_response);
        });
    }

    protected processShowWebPage(response: Response): Promise<ShowWebPageResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShowWebPageResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = DeviceException.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ShowWebPageResponse>(null as any);
    }

    /**
     * Bioauthenticates the user
     * @return OK
     */
    bioAuthenticate(body: BioAuthenticationRequest): Promise<BioMetricAuthenticationResponse> {
        let url_ = this.baseUrl + "/api/ClientDeviceInterface/BioAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBioAuthenticate(_response);
        });
    }

    protected processBioAuthenticate(response: Response): Promise<BioMetricAuthenticationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BioMetricAuthenticationResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = DeviceException.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BioMetricAuthenticationResponse>(null as any);
    }

    /**
     * Listens to beacons in the surroundings
     * @return OK
     */
    listenToBeacons(body: ListenToBeaconsRequest): Promise<ListenToBeaconsResponse> {
        let url_ = this.baseUrl + "/api/ClientDeviceInterface/ListenToBeacons";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processListenToBeacons(_response);
        });
    }

    protected processListenToBeacons(response: Response): Promise<ListenToBeaconsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListenToBeaconsResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = DeviceException.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ListenToBeaconsResponse>(null as any);
    }

    /**
     * Shows Qr Code
     * @return OK
     */
    showQrCode(body: ShowQrCodeRequest): Promise<void> {
        let url_ = this.baseUrl + "/api/ClientDeviceInterface/ShowQrCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processShowQrCode(_response);
        });
    }

    protected processShowQrCode(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export interface IClientSensorsClient {

    /**
     * Gets the list of sensors
     * @return OK
     */
    getListOfSensors(): Promise<SensorsConfigurationResponse>;
}

export class ClientSensorsClient extends BaseClient implements IClientSensorsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Gets the list of sensors
     * @return OK
     */
    getListOfSensors(): Promise<SensorsConfigurationResponse> {
        let url_ = this.baseUrl + "/api/ClientSensors/GetListOfSensors";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetListOfSensors(_response);
        });
    }

    protected processGetListOfSensors(response: Response): Promise<SensorsConfigurationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SensorsConfigurationResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SensorsConfigurationResponse>(null as any);
    }
}

export interface IClientTicketDefinitionsClient {

    /**
     * Gets the list of ticket definitions
     * @return OK
     */
    getListOfTicketDefinitions(): Promise<TicketConfigurationResponse>;
}

export class ClientTicketDefinitionsClient extends BaseClient implements IClientTicketDefinitionsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Gets the list of ticket definitions
     * @return OK
     */
    getListOfTicketDefinitions(): Promise<TicketConfigurationResponse> {
        let url_ = this.baseUrl + "/api/ClientTicketDefinitions/GetListOfTicketDefinitions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetListOfTicketDefinitions(_response);
        });
    }

    protected processGetListOfTicketDefinitions(response: Response): Promise<TicketConfigurationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TicketConfigurationResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TicketConfigurationResponse>(null as any);
    }
}

export interface IClientWalletClient {

    /**
     * Searches the user by username
     * @return OK
     */
    searchUser(username: string): Promise<SearchUserResponse>;

    /**
     * Gets the users wallet
     * @return OK
     */
    getWalletByClient(userid: string): Promise<ClientWalletResponse>;

    /**
     * Creates a ticket in the users wallet
     * @return OK
     */
    createTicket(body: CreateTicketRequest): Promise<CreateTicketResponse>;

    /**
     * Creates a ticket log
     * @return OK
     */
    createTicketLog(body: CreateTicketLogRequest): Promise<string>;

    /**
     * Updates the ticket
     * @return OK
     */
    updateTicket(body: UpdateTicketRequest): Promise<void>;

    /**
     * Deletes the ticket
     * @return OK
     */
    deleteTicket(body: DeleteTicketRequest): Promise<void>;

    /**
     * Gets the actions belongint to this ticket
     * @return OK
     */
    getTicketActions(ticketId: string): Promise<ClientTicketAction[]>;

    /**
     * Gets the ticket specified by the id
     * @return OK
     */
    getTicketById(ticketId: string): Promise<ClientWalletTicket>;
}

export class ClientWalletClient extends BaseClient implements IClientWalletClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Searches the user by username
     * @return OK
     */
    searchUser(username: string): Promise<SearchUserResponse> {
        let url_ = this.baseUrl + "/api/ClientWallet/SearchUser?";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined and cannot be null.");
        else
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchUser(_response);
        });
    }

    protected processSearchUser(response: Response): Promise<SearchUserResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SearchUserResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchUserResponse>(null as any);
    }

    /**
     * Gets the users wallet
     * @return OK
     */
    getWalletByClient(userid: string): Promise<ClientWalletResponse> {
        let url_ = this.baseUrl + "/api/ClientWallet/GetWalletByClient?";
        if (userid === undefined || userid === null)
            throw new Error("The parameter 'userid' must be defined and cannot be null.");
        else
            url_ += "userid=" + encodeURIComponent("" + userid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetWalletByClient(_response);
        });
    }

    protected processGetWalletByClient(response: Response): Promise<ClientWalletResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientWalletResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientWalletResponse>(null as any);
    }

    /**
     * Creates a ticket in the users wallet
     * @return OK
     */
    createTicket(body: CreateTicketRequest): Promise<CreateTicketResponse> {
        let url_ = this.baseUrl + "/api/ClientWallet/CreateTicket";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateTicket(_response);
        });
    }

    protected processCreateTicket(response: Response): Promise<CreateTicketResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateTicketResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreateTicketResponse>(null as any);
    }

    /**
     * Creates a ticket log
     * @return OK
     */
    createTicketLog(body: CreateTicketLogRequest): Promise<string> {
        let url_ = this.baseUrl + "/api/ClientWallet/CreateTicketLog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateTicketLog(_response);
        });
    }

    protected processCreateTicketLog(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * Updates the ticket
     * @return OK
     */
    updateTicket(body: UpdateTicketRequest): Promise<void> {
        let url_ = this.baseUrl + "/api/ClientWallet/UpdateTicket";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdateTicket(_response);
        });
    }

    protected processUpdateTicket(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Deletes the ticket
     * @return OK
     */
    deleteTicket(body: DeleteTicketRequest): Promise<void> {
        let url_ = this.baseUrl + "/api/ClientWallet/DeleteTicket";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDeleteTicket(_response);
        });
    }

    protected processDeleteTicket(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Gets the actions belongint to this ticket
     * @return OK
     */
    getTicketActions(ticketId: string): Promise<ClientTicketAction[]> {
        let url_ = this.baseUrl + "/api/ClientWallet/GetTicketActions?";
        if (ticketId === undefined || ticketId === null)
            throw new Error("The parameter 'ticketId' must be defined and cannot be null.");
        else
            url_ += "ticketId=" + encodeURIComponent("" + ticketId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTicketActions(_response);
        });
    }

    protected processGetTicketActions(response: Response): Promise<ClientTicketAction[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ClientTicketAction.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientTicketAction[]>(null as any);
    }

    /**
     * Gets the ticket specified by the id
     * @return OK
     */
    getTicketById(ticketId: string): Promise<ClientWalletTicket> {
        let url_ = this.baseUrl + "/api/ClientWallet/GetTicketById?";
        if (ticketId === undefined || ticketId === null)
            throw new Error("The parameter 'ticketId' must be defined and cannot be null.");
        else
            url_ += "ticketId=" + encodeURIComponent("" + ticketId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTicketById(_response);
        });
    }

    protected processGetTicketById(response: Response): Promise<ClientWalletTicket> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClientWalletTicket.fromJS(resultData200);
            return result200;
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ClientWalletTicket>(null as any);
    }
}

export interface IDemoClient {

    /**
     * Verifies the credentials for the playground
     * @return OK
     */
    verifyCredentials(body: VerifyDto): Promise<VerifyCredentialsResult>;

    /**
     * Verifies the credentials for the playground
     * @return OK
     */
    verifyCredentialsUserId(body: VerifyUserIdDto): Promise<VerifyCredentialsUserIdResult>;
}

export class DemoClient extends BaseClient implements IDemoClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * Verifies the credentials for the playground
     * @return OK
     */
    verifyCredentials(body: VerifyDto): Promise<VerifyCredentialsResult> {
        let url_ = this.baseUrl + "/api/Demo/VerifyCredentials";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processVerifyCredentials(_response);
        });
    }

    protected processVerifyCredentials(response: Response): Promise<VerifyCredentialsResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VerifyCredentialsResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VerifyCredentialsResult>(null as any);
    }

    /**
     * Verifies the credentials for the playground
     * @return OK
     */
    verifyCredentialsUserId(body: VerifyUserIdDto): Promise<VerifyCredentialsUserIdResult> {
        let url_ = this.baseUrl + "/api/Demo/VerifyCredentialsUserId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processVerifyCredentialsUserId(_response);
        });
    }

    protected processVerifyCredentialsUserId(response: Response): Promise<VerifyCredentialsUserIdResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VerifyCredentialsUserIdResult.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorModel.fromJS(resultData500);
            return throwException("Internal Server Error", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VerifyCredentialsUserIdResult>(null as any);
    }
}

export interface IPushNotificationsClient {

    /**
     * @return Success
     */
    sendToTicket(body: SendToTicketRequest): Promise<boolean>;
}

export class PushNotificationsClient extends BaseClient implements IPushNotificationsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return Success
     */
    sendToTicket(body: SendToTicketRequest): Promise<boolean> {
        let url_ = this.baseUrl + "/api/PushNotifications/SendToTicket";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSendToTicket(_response);
        });
    }

    protected processSendToTicket(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export enum ActionType {
    Created = "Created",
    Updated = "Updated",
    Deleted = "Deleted",
}

export enum ActionTypeEnum {
    Nothing = "Nothing",
    ShowTicket = "ShowTicket",
    RefreshTicket = "RefreshTicket",
    RefreshTicketList = "RefreshTicketList",
    Sensor = "Sensor",
    ShowUrl = "ShowUrl",
    ShowMenu = "ShowMenu",
    ShowMessage = "ShowMessage",
    ShowMultiple = "ShowMultiple",
    ShowPrompt = "ShowPrompt",
    ShowQrCode = "ShowQrCode",
    BioAuthenticate = "BioAuthenticate",
    ListenToBeacons = "ListenToBeacons",
    NoTicket = "NoTicket",
    ShowWebPage = "ShowWebPage",
}

export enum AuthenticationMethod {
    Bio = "Bio",
    Pin = "Pin",
}

export class BaseAction implements IBaseAction {

    protected _discriminator: string;

    constructor(data?: IBaseAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "BaseAction";
    }

    init(_data?: any) {
    }

    static fromJS(data: any): BaseAction {
        data = typeof data === 'object' ? data : {};
        if (data["actionType"] === "Sensor") {
            let result = new SensorAction();
            result.init(data);
            return result;
        }
        if (data["actionType"] === "ShowTicket") {
            let result = new ShowTicketAction();
            result.init(data);
            return result;
        }
        if (data["actionType"] === "RefreshTicketList") {
            let result = new RefreshTicketListAction();
            result.init(data);
            return result;
        }
        if (data["actionType"] === "RefreshTicket") {
            let result = new RefreshTicketAction();
            result.init(data);
            return result;
        }
        if (data["actionType"] === "ShowUrl") {
            let result = new ShowUrlAction();
            result.init(data);
            return result;
        }
        let result = new BaseAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionType"] = this._discriminator;
        return data;
    }
}

export interface IBaseAction {
}

export class BioAuthenticationRequest implements IBioAuthenticationRequest {
    communicationId!: string;
    title!: string;
    allowAlternative!: boolean;
    reason!: string;
    timeoutSek!: number;

    constructor(data?: IBioAuthenticationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.communicationId = _data["communicationId"];
            this.title = _data["title"];
            this.allowAlternative = _data["allowAlternative"];
            this.reason = _data["reason"];
            this.timeoutSek = _data["timeoutSek"];
        }
    }

    static fromJS(data: any): BioAuthenticationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new BioAuthenticationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["communicationId"] = this.communicationId;
        data["title"] = this.title;
        data["allowAlternative"] = this.allowAlternative;
        data["reason"] = this.reason;
        data["timeoutSek"] = this.timeoutSek;
        return data;
    }
}

export interface IBioAuthenticationRequest {
    communicationId: string;
    title: string;
    allowAlternative: boolean;
    reason: string;
    timeoutSek: number;
}

export class BioMetricAuthenticationResponse implements IBioMetricAuthenticationResponse {
    succeeded!: boolean;
    authenticationMethod!: AuthenticationMethod;

    constructor(data?: IBioMetricAuthenticationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.authenticationMethod = _data["authenticationMethod"];
        }
    }

    static fromJS(data: any): BioMetricAuthenticationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BioMetricAuthenticationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["authenticationMethod"] = this.authenticationMethod;
        return data;
    }
}

export interface IBioMetricAuthenticationResponse {
    succeeded: boolean;
    authenticationMethod: AuthenticationMethod;
}

export class Choice implements IChoice {
    id!: number;
    text!: string;
    defaultValue!: boolean;

    constructor(data?: IChoice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
            this.defaultValue = _data["defaultValue"];
        }
    }

    static fromJS(data: any): Choice {
        data = typeof data === 'object' ? data : {};
        let result = new Choice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["defaultValue"] = this.defaultValue;
        return data;
    }
}

export interface IChoice {
    id: number;
    text: string;
    defaultValue: boolean;
}

export class ClientTicketAction implements IClientTicketAction {
    id?: string;
    actionType?: ActionType;
    name?: string | undefined;
    data?: string | undefined;
    presentationData?: string | undefined;
    presentationType?: string | undefined;
    actionTime?: Date;
    note?: string | undefined;

    constructor(data?: IClientTicketAction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.actionType = _data["actionType"];
            this.name = _data["name"];
            this.data = _data["data"];
            this.presentationData = _data["presentationData"];
            this.presentationType = _data["presentationType"];
            this.actionTime = _data["actionTime"] ? new Date(_data["actionTime"].toString()) : <any>undefined;
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): ClientTicketAction {
        data = typeof data === 'object' ? data : {};
        let result = new ClientTicketAction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["actionType"] = this.actionType;
        data["name"] = this.name;
        data["data"] = this.data;
        data["presentationData"] = this.presentationData;
        data["presentationType"] = this.presentationType;
        data["actionTime"] = this.actionTime ? this.actionTime.toISOString() : <any>undefined;
        data["note"] = this.note;
        return data;
    }
}

export interface IClientTicketAction {
    id?: string;
    actionType?: ActionType;
    name?: string | undefined;
    data?: string | undefined;
    presentationData?: string | undefined;
    presentationType?: string | undefined;
    actionTime?: Date;
    note?: string | undefined;
}

export class ClientWalletResponse implements IClientWalletResponse {
    id?: string;
    userName!: string;
    name?: string | undefined;
    phoneNumber?: string | undefined;
    tickets!: ClientWalletTicket[];

    constructor(data?: IClientWalletResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.tickets = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.phoneNumber = _data["phoneNumber"];
            if (Array.isArray(_data["tickets"])) {
                this.tickets = [] as any;
                for (let item of _data["tickets"])
                    this.tickets!.push(ClientWalletTicket.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ClientWalletResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ClientWalletResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["phoneNumber"] = this.phoneNumber;
        if (Array.isArray(this.tickets)) {
            data["tickets"] = [];
            for (let item of this.tickets)
                data["tickets"].push(item.toJSON());
        }
        return data;
    }
}

export interface IClientWalletResponse {
    id?: string;
    userName: string;
    name?: string | undefined;
    phoneNumber?: string | undefined;
    tickets: ClientWalletTicket[];
}

export class ClientWalletTicket implements IClientWalletTicket {
    id?: string;
    ticketDefinitionId?: string;
    name?: string | undefined;
    data?: string | undefined;
    template?: Template | undefined;
    detailTemplate?: DetailTemplate | undefined;
    pushNotifications?: TicketAccess;
    beacons?: TicketAccess;
    locations?: TicketAccess;

    constructor(data?: IClientWalletTicket) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ticketDefinitionId = _data["ticketDefinitionId"];
            this.name = _data["name"];
            this.data = _data["data"];
            this.template = _data["template"] ? Template.fromJS(_data["template"]) : <any>undefined;
            this.detailTemplate = _data["detailTemplate"] ? DetailTemplate.fromJS(_data["detailTemplate"]) : <any>undefined;
            this.pushNotifications = _data["pushNotifications"];
            this.beacons = _data["beacons"];
            this.locations = _data["locations"];
        }
    }

    static fromJS(data: any): ClientWalletTicket {
        data = typeof data === 'object' ? data : {};
        let result = new ClientWalletTicket();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ticketDefinitionId"] = this.ticketDefinitionId;
        data["name"] = this.name;
        data["data"] = this.data;
        data["template"] = this.template ? this.template.toJSON() : <any>undefined;
        data["detailTemplate"] = this.detailTemplate ? this.detailTemplate.toJSON() : <any>undefined;
        data["pushNotifications"] = this.pushNotifications;
        data["beacons"] = this.beacons;
        data["locations"] = this.locations;
        return data;
    }
}

export interface IClientWalletTicket {
    id?: string;
    ticketDefinitionId?: string;
    name?: string | undefined;
    data?: string | undefined;
    template?: Template | undefined;
    detailTemplate?: DetailTemplate | undefined;
    pushNotifications?: TicketAccess;
    beacons?: TicketAccess;
    locations?: TicketAccess;
}

export class CreateTicketLogRequest implements ICreateTicketLogRequest {
    ticketId!: string;
    logTemplate!: LogTemplate1;

    constructor(data?: ICreateTicketLogRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.logTemplate = new LogTemplate1();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ticketId = _data["ticketId"];
            this.logTemplate = _data["logTemplate"] ? LogTemplate1.fromJS(_data["logTemplate"]) : new LogTemplate1();
        }
    }

    static fromJS(data: any): CreateTicketLogRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTicketLogRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketId"] = this.ticketId;
        data["logTemplate"] = this.logTemplate ? this.logTemplate.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateTicketLogRequest {
    ticketId: string;
    logTemplate: LogTemplate1;
}

export class CreateTicketRequest implements ICreateTicketRequest {
    userId!: string;
    name!: string;
    ticketDefinitionId!: string;
    data!: string;
    detailTemplate!: DetailTemplate;
    template!: Template;
    note!: string;

    constructor(data?: ICreateTicketRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.detailTemplate = new DetailTemplate();
            this.template = new Template();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.ticketDefinitionId = _data["ticketDefinitionId"];
            this.data = _data["data"];
            this.detailTemplate = _data["detailTemplate"] ? DetailTemplate.fromJS(_data["detailTemplate"]) : new DetailTemplate();
            this.template = _data["template"] ? Template.fromJS(_data["template"]) : new Template();
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): CreateTicketRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTicketRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["ticketDefinitionId"] = this.ticketDefinitionId;
        data["data"] = this.data;
        data["detailTemplate"] = this.detailTemplate ? this.detailTemplate.toJSON() : <any>undefined;
        data["template"] = this.template ? this.template.toJSON() : <any>undefined;
        data["note"] = this.note;
        return data;
    }
}

export interface ICreateTicketRequest {
    userId: string;
    name: string;
    ticketDefinitionId: string;
    data: string;
    detailTemplate: DetailTemplate;
    template: Template;
    note: string;
}

export class CreateTicketResponse implements ICreateTicketResponse {
    ticketId!: string;

    constructor(data?: ICreateTicketResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ticketId = _data["ticketId"];
        }
    }

    static fromJS(data: any): CreateTicketResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTicketResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketId"] = this.ticketId;
        return data;
    }
}

export interface ICreateTicketResponse {
    ticketId: string;
}

export class DeleteTicketRequest implements IDeleteTicketRequest {
    ticketId!: string;
    note!: string;

    constructor(data?: IDeleteTicketRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ticketId = _data["ticketId"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): DeleteTicketRequest {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteTicketRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketId"] = this.ticketId;
        data["note"] = this.note;
        return data;
    }
}

export interface IDeleteTicketRequest {
    ticketId: string;
    note: string;
}

export class DetailTemplate implements IDetailTemplate {

    protected _discriminator: string;

    constructor(data?: IDetailTemplate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "DetailTemplate";
    }

    init(_data?: any) {
    }

    static fromJS(data: any): DetailTemplate {
        data = typeof data === 'object' ? data : {};
        if (data["detailType"] === "DT1") {
            let result = new DetailTemplate1();
            result.init(data);
            return result;
        }
        if (data["detailType"] === "WebPageDetailTemplate") {
            let result = new WebPageDetailTemplate();
            result.init(data);
            return result;
        }
        let result = new DetailTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["detailType"] = this._discriminator;
        return data;
    }
}

export interface IDetailTemplate {
}

export class DetailTemplate1 extends DetailTemplate implements IDetailTemplate1 {
    image?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    time?: Date | undefined;
    expiry?: Date | undefined;
    buttons?: TemplateButton[] | undefined;
    detailType!: DetailTemplateTypeEnum;

    constructor(data?: IDetailTemplate1) {
        super(data);
        this._discriminator = "DT1";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.image = _data["image"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.time = _data["time"] ? new Date(_data["time"].toString()) : <any>undefined;
            this.expiry = _data["expiry"] ? new Date(_data["expiry"].toString()) : <any>undefined;
            if (Array.isArray(_data["buttons"])) {
                this.buttons = [] as any;
                for (let item of _data["buttons"])
                    this.buttons!.push(TemplateButton.fromJS(item));
            }
            this.detailType = _data["detailType"];
        }
    }

    static override fromJS(data: any): DetailTemplate1 {
        data = typeof data === 'object' ? data : {};
        let result = new DetailTemplate1();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["image"] = this.image;
        data["title"] = this.title;
        data["description"] = this.description;
        data["time"] = this.time ? this.time.toISOString() : <any>undefined;
        data["expiry"] = this.expiry ? this.expiry.toISOString() : <any>undefined;
        if (Array.isArray(this.buttons)) {
            data["buttons"] = [];
            for (let item of this.buttons)
                data["buttons"].push(item.toJSON());
        }
        data["detailType"] = this.detailType;
        super.toJSON(data);
        return data;
    }
}

export interface IDetailTemplate1 extends IDetailTemplate {
    image?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    time?: Date | undefined;
    expiry?: Date | undefined;
    buttons?: TemplateButton[] | undefined;
    detailType: DetailTemplateTypeEnum;
}

export enum DetailTemplateTypeEnum {
    DT1 = "DT1",
    WebPageDetailTemplate = "WebPageDetailTemplate",
    Abstract = "Abstract",
}

export class DeviceException implements IDeviceException {
    statusDetail!: StatusDetail;

    constructor(data?: IDeviceException) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusDetail = _data["statusDetail"];
        }
    }

    static fromJS(data: any): DeviceException {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceException();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusDetail"] = this.statusDetail;
        return data;
    }
}

export interface IDeviceException {
    statusDetail: StatusDetail;
}

export class ErrorModel implements IErrorModel {
    errorCode?: IceCodeErrors;
    error?: string | undefined;

    constructor(data?: IErrorModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorCode = _data["errorCode"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): ErrorModel {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorCode"] = this.errorCode;
        data["error"] = this.error;
        return data;
    }
}

export interface IErrorModel {
    errorCode?: IceCodeErrors;
    error?: string | undefined;
}

export enum IceCodeErrors {
    _1 = 1,
    _100 = 100,
}

export class ListenToBeaconsRequest implements IListenToBeaconsRequest {
    communicationId!: string;
    ticketId!: string;
    beacons!: string[];
    parameter!: string;
    notifyNotFoundSek!: number;
    timeoutSek!: number;

    constructor(data?: IListenToBeaconsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.beacons = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.communicationId = _data["communicationId"];
            this.ticketId = _data["ticketId"];
            if (Array.isArray(_data["beacons"])) {
                this.beacons = [] as any;
                for (let item of _data["beacons"])
                    this.beacons!.push(item);
            }
            this.parameter = _data["parameter"];
            this.notifyNotFoundSek = _data["notifyNotFoundSek"];
            this.timeoutSek = _data["timeoutSek"];
        }
    }

    static fromJS(data: any): ListenToBeaconsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ListenToBeaconsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["communicationId"] = this.communicationId;
        data["ticketId"] = this.ticketId;
        if (Array.isArray(this.beacons)) {
            data["beacons"] = [];
            for (let item of this.beacons)
                data["beacons"].push(item);
        }
        data["parameter"] = this.parameter;
        data["notifyNotFoundSek"] = this.notifyNotFoundSek;
        data["timeoutSek"] = this.timeoutSek;
        return data;
    }
}

export interface IListenToBeaconsRequest {
    communicationId: string;
    ticketId: string;
    beacons: string[];
    parameter: string;
    notifyNotFoundSek: number;
    timeoutSek: number;
}

export class ListenToBeaconsResponse implements IListenToBeaconsResponse {
    succeeded!: boolean;

    constructor(data?: IListenToBeaconsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
        }
    }

    static fromJS(data: any): ListenToBeaconsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ListenToBeaconsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        return data;
    }
}

export interface IListenToBeaconsResponse {
    succeeded: boolean;
}

export class LogTemplate implements ILogTemplate {

    protected _discriminator: string;

    constructor(data?: ILogTemplate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "LogTemplate";
    }

    init(_data?: any) {
    }

    static fromJS(data: any): LogTemplate {
        data = typeof data === 'object' ? data : {};
        if (data["templateType"] === "T1") {
            let result = new LogTemplate1();
            result.init(data);
            return result;
        }
        let result = new LogTemplate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateType"] = this._discriminator;
        return data;
    }
}

export interface ILogTemplate {
}

export class LogTemplate1 extends LogTemplate implements ILogTemplate1 {
    title?: string | undefined;
    description?: string | undefined;
    time!: Date;
    templateType!: LogTemplateTypeEnum;

    constructor(data?: ILogTemplate1) {
        super(data);
        this._discriminator = "T1";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"];
            this.description = _data["description"];
            this.time = _data["time"] ? new Date(_data["time"].toString()) : <any>undefined;
            this.templateType = _data["templateType"];
        }
    }

    static override fromJS(data: any): LogTemplate1 {
        data = typeof data === 'object' ? data : {};
        let result = new LogTemplate1();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["description"] = this.description;
        data["time"] = this.time ? this.time.toISOString() : <any>undefined;
        data["templateType"] = this.templateType;
        super.toJSON(data);
        return data;
    }
}

export interface ILogTemplate1 extends ILogTemplate {
    title?: string | undefined;
    description?: string | undefined;
    time: Date;
    templateType: LogTemplateTypeEnum;
}

export enum LogTemplateTypeEnum {
    T1 = "T1",
}

export class RefreshTicketAction extends BaseAction implements IRefreshTicketAction {
    ticketId!: string;
    actionType!: ActionTypeEnum;

    constructor(data?: IRefreshTicketAction) {
        super(data);
        this._discriminator = "RefreshTicket";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.ticketId = _data["ticketId"];
            this.actionType = _data["actionType"];
        }
    }

    static override fromJS(data: any): RefreshTicketAction {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTicketAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketId"] = this.ticketId;
        data["actionType"] = this.actionType;
        super.toJSON(data);
        return data;
    }
}

export interface IRefreshTicketAction extends IBaseAction {
    ticketId: string;
    actionType: ActionTypeEnum;
}

export class RefreshTicketListAction extends BaseAction implements IRefreshTicketListAction {
    actionType!: ActionTypeEnum;

    constructor(data?: IRefreshTicketListAction) {
        super(data);
        this._discriminator = "RefreshTicketList";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.actionType = _data["actionType"];
        }
    }

    static override fromJS(data: any): RefreshTicketListAction {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTicketListAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionType"] = this.actionType;
        super.toJSON(data);
        return data;
    }
}

export interface IRefreshTicketListAction extends IBaseAction {
    actionType: ActionTypeEnum;
}

export class ReturnChoice implements IReturnChoice {
    id!: number;
    value!: boolean;

    constructor(data?: IReturnChoice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ReturnChoice {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnChoice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        return data;
    }
}

export interface IReturnChoice {
    id: number;
    value: boolean;
}

export class SearchUserResponse implements ISearchUserResponse {
    userId!: string;
    languageId!: string;

    constructor(data?: ISearchUserResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.languageId = _data["languageId"];
        }
    }

    static fromJS(data: any): SearchUserResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SearchUserResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["languageId"] = this.languageId;
        return data;
    }
}

export interface ISearchUserResponse {
    userId: string;
    languageId: string;
}

export class SendToTicketRequest implements ISendToTicketRequest {
    ticketId!: string;
    title!: string;
    body!: string;
    actions!: BaseAction[];
    image?: string | undefined;
    priority!: number;

    constructor(data?: ISendToTicketRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.actions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ticketId = _data["ticketId"];
            this.title = _data["title"];
            this.body = _data["body"];
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(BaseAction.fromJS(item));
            }
            this.image = _data["image"];
            this.priority = _data["priority"];
        }
    }

    static fromJS(data: any): SendToTicketRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SendToTicketRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketId"] = this.ticketId;
        data["title"] = this.title;
        data["body"] = this.body;
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item.toJSON());
        }
        data["image"] = this.image;
        data["priority"] = this.priority;
        return data;
    }
}

export interface ISendToTicketRequest {
    ticketId: string;
    title: string;
    body: string;
    actions: BaseAction[];
    image?: string | undefined;
    priority: number;
}

export class Sensor implements ISensor {
    id?: string;
    name?: string | undefined;
    sensorType?: SensorType;
    description?: string | undefined;
    enabled?: boolean;
    ticketsActive?: TicketActive[] | undefined;

    constructor(data?: ISensor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.sensorType = _data["sensorType"];
            this.description = _data["description"];
            this.enabled = _data["enabled"];
            if (Array.isArray(_data["ticketsActive"])) {
                this.ticketsActive = [] as any;
                for (let item of _data["ticketsActive"])
                    this.ticketsActive!.push(TicketActive.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Sensor {
        data = typeof data === 'object' ? data : {};
        let result = new Sensor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["sensorType"] = this.sensorType;
        data["description"] = this.description;
        data["enabled"] = this.enabled;
        if (Array.isArray(this.ticketsActive)) {
            data["ticketsActive"] = [];
            for (let item of this.ticketsActive)
                data["ticketsActive"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISensor {
    id?: string;
    name?: string | undefined;
    sensorType?: SensorType;
    description?: string | undefined;
    enabled?: boolean;
    ticketsActive?: TicketActive[] | undefined;
}

export class SensorAction extends BaseAction implements ISensorAction {
    sensorId!: string;
    actionType!: ActionTypeEnum;

    constructor(data?: ISensorAction) {
        super(data);
        this._discriminator = "Sensor";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.sensorId = _data["sensorId"];
            this.actionType = _data["actionType"];
        }
    }

    static override fromJS(data: any): SensorAction {
        data = typeof data === 'object' ? data : {};
        let result = new SensorAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sensorId"] = this.sensorId;
        data["actionType"] = this.actionType;
        super.toJSON(data);
        return data;
    }
}

export interface ISensorAction extends IBaseAction {
    sensorId: string;
    actionType: ActionTypeEnum;
}

export enum SensorType {
    Normal = "Normal",
    Push = "Push",
    Beacon = "Beacon",
}

export class SensorsConfigurationResponse implements ISensorsConfigurationResponse {
    sensors!: Sensor[];

    constructor(data?: ISensorsConfigurationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sensors = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sensors"])) {
                this.sensors = [] as any;
                for (let item of _data["sensors"])
                    this.sensors!.push(Sensor.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SensorsConfigurationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SensorsConfigurationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sensors)) {
            data["sensors"] = [];
            for (let item of this.sensors)
                data["sensors"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISensorsConfigurationResponse {
    sensors: Sensor[];
}

export class ShowMenuRequest implements IShowMenuRequest {
    communicationId!: string;
    message!: string;
    options!: string[];
    timeoutSek!: number;
    image?: string | undefined;
    title!: string;

    constructor(data?: IShowMenuRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.options = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.communicationId = _data["communicationId"];
            this.message = _data["message"];
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(item);
            }
            this.timeoutSek = _data["timeoutSek"];
            this.image = _data["image"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): ShowMenuRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShowMenuRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["communicationId"] = this.communicationId;
        data["message"] = this.message;
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item);
        }
        data["timeoutSek"] = this.timeoutSek;
        data["image"] = this.image;
        data["title"] = this.title;
        return data;
    }
}

export interface IShowMenuRequest {
    communicationId: string;
    message: string;
    options: string[];
    timeoutSek: number;
    image?: string | undefined;
    title: string;
}

export class ShowMenuResponse implements IShowMenuResponse {
    statusDetail?: StatusDetail;
    selectedValue!: string;

    constructor(data?: IShowMenuResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusDetail = _data["statusDetail"];
            this.selectedValue = _data["selectedValue"];
        }
    }

    static fromJS(data: any): ShowMenuResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ShowMenuResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusDetail"] = this.statusDetail;
        data["selectedValue"] = this.selectedValue;
        return data;
    }
}

export interface IShowMenuResponse {
    statusDetail?: StatusDetail;
    selectedValue: string;
}

export class ShowMessageRequest implements IShowMessageRequest {
    communicationId!: string;
    image?: string | undefined;
    title!: string;
    message!: string;
    timeoutSek!: number;
    close!: string;

    constructor(data?: IShowMessageRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.communicationId = _data["communicationId"];
            this.image = _data["image"];
            this.title = _data["title"];
            this.message = _data["message"];
            this.timeoutSek = _data["timeoutSek"];
            this.close = _data["close"];
        }
    }

    static fromJS(data: any): ShowMessageRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShowMessageRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["communicationId"] = this.communicationId;
        data["image"] = this.image;
        data["title"] = this.title;
        data["message"] = this.message;
        data["timeoutSek"] = this.timeoutSek;
        data["close"] = this.close;
        return data;
    }
}

export interface IShowMessageRequest {
    communicationId: string;
    image?: string | undefined;
    title: string;
    message: string;
    timeoutSek: number;
    close: string;
}

export class ShowMultipleChoiceRequest implements IShowMultipleChoiceRequest {
    communicationId!: string;
    message!: string;
    closeText!: string;
    options!: Choice[];
    timeoutSek!: number;
    image?: string | undefined;
    title?: string | undefined;

    constructor(data?: IShowMultipleChoiceRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.options = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.communicationId = _data["communicationId"];
            this.message = _data["message"];
            this.closeText = _data["closeText"];
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(Choice.fromJS(item));
            }
            this.timeoutSek = _data["timeoutSek"];
            this.image = _data["image"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): ShowMultipleChoiceRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShowMultipleChoiceRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["communicationId"] = this.communicationId;
        data["message"] = this.message;
        data["closeText"] = this.closeText;
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        data["timeoutSek"] = this.timeoutSek;
        data["image"] = this.image;
        data["title"] = this.title;
        return data;
    }
}

export interface IShowMultipleChoiceRequest {
    communicationId: string;
    message: string;
    closeText: string;
    options: Choice[];
    timeoutSek: number;
    image?: string | undefined;
    title?: string | undefined;
}

export class ShowMultipleChoiceResponse implements IShowMultipleChoiceResponse {
    statusDetail?: StatusDetail;
    choices!: ReturnChoice[];

    constructor(data?: IShowMultipleChoiceResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.choices = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusDetail = _data["statusDetail"];
            if (Array.isArray(_data["choices"])) {
                this.choices = [] as any;
                for (let item of _data["choices"])
                    this.choices!.push(ReturnChoice.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ShowMultipleChoiceResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ShowMultipleChoiceResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusDetail"] = this.statusDetail;
        if (Array.isArray(this.choices)) {
            data["choices"] = [];
            for (let item of this.choices)
                data["choices"].push(item.toJSON());
        }
        return data;
    }
}

export interface IShowMultipleChoiceResponse {
    statusDetail?: StatusDetail;
    choices: ReturnChoice[];
}

export class ShowPromptRequest implements IShowPromptRequest {
    communicationId!: string;
    image?: string | undefined;
    title!: string;
    message!: string;
    yes!: string;
    no!: string;
    timeoutSek!: number;

    constructor(data?: IShowPromptRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.communicationId = _data["communicationId"];
            this.image = _data["image"];
            this.title = _data["title"];
            this.message = _data["message"];
            this.yes = _data["yes"];
            this.no = _data["no"];
            this.timeoutSek = _data["timeoutSek"];
        }
    }

    static fromJS(data: any): ShowPromptRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShowPromptRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["communicationId"] = this.communicationId;
        data["image"] = this.image;
        data["title"] = this.title;
        data["message"] = this.message;
        data["yes"] = this.yes;
        data["no"] = this.no;
        data["timeoutSek"] = this.timeoutSek;
        return data;
    }
}

export interface IShowPromptRequest {
    communicationId: string;
    image?: string | undefined;
    title: string;
    message: string;
    yes: string;
    no: string;
    timeoutSek: number;
}

export class ShowPromptResponse implements IShowPromptResponse {
    statusDetail?: StatusDetail;
    result!: boolean;
    extra?: string | undefined;

    constructor(data?: IShowPromptResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusDetail = _data["statusDetail"];
            this.result = _data["result"];
            this.extra = _data["extra"];
        }
    }

    static fromJS(data: any): ShowPromptResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ShowPromptResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusDetail"] = this.statusDetail;
        data["result"] = this.result;
        data["extra"] = this.extra;
        return data;
    }
}

export interface IShowPromptResponse {
    statusDetail?: StatusDetail;
    result: boolean;
    extra?: string | undefined;
}

export class ShowQrCodeRequest implements IShowQrCodeRequest {
    communicationId!: string;
    message!: string;
    qrCode!: string;
    timeoutSek!: number;
    image?: string | undefined;
    title!: string;

    constructor(data?: IShowQrCodeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.communicationId = _data["communicationId"];
            this.message = _data["message"];
            this.qrCode = _data["qrCode"];
            this.timeoutSek = _data["timeoutSek"];
            this.image = _data["image"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): ShowQrCodeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShowQrCodeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["communicationId"] = this.communicationId;
        data["message"] = this.message;
        data["qrCode"] = this.qrCode;
        data["timeoutSek"] = this.timeoutSek;
        data["image"] = this.image;
        data["title"] = this.title;
        return data;
    }
}

export interface IShowQrCodeRequest {
    communicationId: string;
    message: string;
    qrCode: string;
    timeoutSek: number;
    image?: string | undefined;
    title: string;
}

export class ShowTicketAction extends BaseAction implements IShowTicketAction {
    ticketId!: string;
    actionType!: ActionTypeEnum;

    constructor(data?: IShowTicketAction) {
        super(data);
        this._discriminator = "ShowTicket";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.ticketId = _data["ticketId"];
            this.actionType = _data["actionType"];
        }
    }

    static override fromJS(data: any): ShowTicketAction {
        data = typeof data === 'object' ? data : {};
        let result = new ShowTicketAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketId"] = this.ticketId;
        data["actionType"] = this.actionType;
        super.toJSON(data);
        return data;
    }
}

export interface IShowTicketAction extends IBaseAction {
    ticketId: string;
    actionType: ActionTypeEnum;
}

export class ShowUrlAction extends BaseAction implements IShowUrlAction {
    url!: string;
    actionType!: ActionTypeEnum;

    constructor(data?: IShowUrlAction) {
        super(data);
        this._discriminator = "ShowUrl";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.url = _data["url"];
            this.actionType = _data["actionType"];
        }
    }

    static override fromJS(data: any): ShowUrlAction {
        data = typeof data === 'object' ? data : {};
        let result = new ShowUrlAction();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["actionType"] = this.actionType;
        super.toJSON(data);
        return data;
    }
}

export interface IShowUrlAction extends IBaseAction {
    url: string;
    actionType: ActionTypeEnum;
}

export class ShowWebPageRequest implements IShowWebPageRequest {
    communicationId!: string;
    loadingText!: string;
    url!: string;
    timeoutSek!: number;

    constructor(data?: IShowWebPageRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.communicationId = _data["communicationId"];
            this.loadingText = _data["loadingText"];
            this.url = _data["url"];
            this.timeoutSek = _data["timeoutSek"];
        }
    }

    static fromJS(data: any): ShowWebPageRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ShowWebPageRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["communicationId"] = this.communicationId;
        data["loadingText"] = this.loadingText;
        data["url"] = this.url;
        data["timeoutSek"] = this.timeoutSek;
        return data;
    }
}

export interface IShowWebPageRequest {
    communicationId: string;
    loadingText: string;
    url: string;
    timeoutSek: number;
}

export class ShowWebPageResponse implements IShowWebPageResponse {
    statusDetail?: StatusDetail;
    result!: string;

    constructor(data?: IShowWebPageResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusDetail = _data["statusDetail"];
            this.result = _data["result"];
        }
    }

    static fromJS(data: any): ShowWebPageResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ShowWebPageResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusDetail"] = this.statusDetail;
        data["result"] = this.result;
        return data;
    }
}

export interface IShowWebPageResponse {
    statusDetail?: StatusDetail;
    result: string;
}

export enum StatusDetail {
    Success = "Success",
    Timeout = "Timeout",
    Cancelled = "Cancelled",
}

export class Template implements ITemplate {

    protected _discriminator: string;

    constructor(data?: ITemplate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        this._discriminator = "Template";
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Template {
        data = typeof data === 'object' ? data : {};
        if (data["templateType"] === "T1") {
            let result = new Template1();
            result.init(data);
            return result;
        }
        let result = new Template();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateType"] = this._discriminator;
        return data;
    }
}

export interface ITemplate {
}

export class Template1 extends Template implements ITemplate1 {
    image?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    time?: Date | undefined;
    expiry?: Date | undefined;
    templateType!: TemplateTypeEnum;

    constructor(data?: ITemplate1) {
        super(data);
        this._discriminator = "T1";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.image = _data["image"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.time = _data["time"] ? new Date(_data["time"].toString()) : <any>undefined;
            this.expiry = _data["expiry"] ? new Date(_data["expiry"].toString()) : <any>undefined;
            this.templateType = _data["templateType"];
        }
    }

    static override fromJS(data: any): Template1 {
        data = typeof data === 'object' ? data : {};
        let result = new Template1();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["image"] = this.image;
        data["title"] = this.title;
        data["description"] = this.description;
        data["time"] = this.time ? this.time.toISOString() : <any>undefined;
        data["expiry"] = this.expiry ? this.expiry.toISOString() : <any>undefined;
        data["templateType"] = this.templateType;
        super.toJSON(data);
        return data;
    }
}

export interface ITemplate1 extends ITemplate {
    image?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    time?: Date | undefined;
    expiry?: Date | undefined;
    templateType: TemplateTypeEnum;
}

export class TemplateButton implements ITemplateButton {
    text!: string;
    action!: BaseAction;

    constructor(data?: ITemplateButton) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.action = new BaseAction();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.action = _data["action"] ? BaseAction.fromJS(_data["action"]) : new BaseAction();
        }
    }

    static fromJS(data: any): TemplateButton {
        data = typeof data === 'object' ? data : {};
        let result = new TemplateButton();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["action"] = this.action ? this.action.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITemplateButton {
    text: string;
    action: BaseAction;
}

export enum TemplateTypeEnum {
    T1 = "T1",
    Abstract = "Abstract",
}

export enum TicketAccess {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class TicketActive implements ITicketActive {
    id?: string;
    ticketName?: string | undefined;

    constructor(data?: ITicketActive) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.ticketName = _data["ticketName"];
        }
    }

    static fromJS(data: any): TicketActive {
        data = typeof data === 'object' ? data : {};
        let result = new TicketActive();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ticketName"] = this.ticketName;
        return data;
    }
}

export interface ITicketActive {
    id?: string;
    ticketName?: string | undefined;
}

export class TicketConfigurationResponse implements ITicketConfigurationResponse {
    ticketDefinitions?: TicketDefinition[] | undefined;

    constructor(data?: ITicketConfigurationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["ticketDefinitions"])) {
                this.ticketDefinitions = [] as any;
                for (let item of _data["ticketDefinitions"])
                    this.ticketDefinitions!.push(TicketDefinition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TicketConfigurationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TicketConfigurationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.ticketDefinitions)) {
            data["ticketDefinitions"] = [];
            for (let item of this.ticketDefinitions)
                data["ticketDefinitions"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITicketConfigurationResponse {
    ticketDefinitions?: TicketDefinition[] | undefined;
}

export class TicketDefinition implements ITicketDefinition {
    id?: string;
    name?: string | undefined;

    constructor(data?: ITicketDefinition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TicketDefinition {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDefinition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ITicketDefinition {
    id?: string;
    name?: string | undefined;
}

export class UpdateTicketRequest implements IUpdateTicketRequest {
    ticketId!: string;
    name!: string;
    data!: string;
    template!: Template;
    detailTemplate!: DetailTemplate;
    note!: string;

    constructor(data?: IUpdateTicketRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.template = new Template();
            this.detailTemplate = new DetailTemplate();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ticketId = _data["ticketId"];
            this.name = _data["name"];
            this.data = _data["data"];
            this.template = _data["template"] ? Template.fromJS(_data["template"]) : new Template();
            this.detailTemplate = _data["detailTemplate"] ? DetailTemplate.fromJS(_data["detailTemplate"]) : new DetailTemplate();
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): UpdateTicketRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTicketRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketId"] = this.ticketId;
        data["name"] = this.name;
        data["data"] = this.data;
        data["template"] = this.template ? this.template.toJSON() : <any>undefined;
        data["detailTemplate"] = this.detailTemplate ? this.detailTemplate.toJSON() : <any>undefined;
        data["note"] = this.note;
        return data;
    }
}

export interface IUpdateTicketRequest {
    ticketId: string;
    name: string;
    data: string;
    template: Template;
    detailTemplate: DetailTemplate;
    note: string;
}

export class VerifyCredentialsResult implements IVerifyCredentialsResult {
    clientUri!: string;
    clientName!: string;

    constructor(data?: IVerifyCredentialsResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientUri = _data["clientUri"];
            this.clientName = _data["clientName"];
        }
    }

    static fromJS(data: any): VerifyCredentialsResult {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyCredentialsResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientUri"] = this.clientUri;
        data["clientName"] = this.clientName;
        return data;
    }
}

export interface IVerifyCredentialsResult {
    clientUri: string;
    clientName: string;
}

export class VerifyCredentialsUserIdResult implements IVerifyCredentialsUserIdResult {
    clientUri!: string;
    userName!: string;
    clientName!: string;

    constructor(data?: IVerifyCredentialsUserIdResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientUri = _data["clientUri"];
            this.userName = _data["userName"];
            this.clientName = _data["clientName"];
        }
    }

    static fromJS(data: any): VerifyCredentialsUserIdResult {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyCredentialsUserIdResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientUri"] = this.clientUri;
        data["userName"] = this.userName;
        data["clientName"] = this.clientName;
        return data;
    }
}

export interface IVerifyCredentialsUserIdResult {
    clientUri: string;
    userName: string;
    clientName: string;
}

export class VerifyDto implements IVerifyDto {
    userName!: string;
    password!: string;
    apiKey!: string;
    destApiKey!: string;

    constructor(data?: IVerifyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.apiKey = _data["apiKey"];
            this.destApiKey = _data["destApiKey"];
        }
    }

    static fromJS(data: any): VerifyDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["apiKey"] = this.apiKey;
        data["destApiKey"] = this.destApiKey;
        return data;
    }
}

export interface IVerifyDto {
    userName: string;
    password: string;
    apiKey: string;
    destApiKey: string;
}

export class VerifyUserIdDto implements IVerifyUserIdDto {
    userId!: string;
    apiKey!: string;
    destApiKey!: string;

    constructor(data?: IVerifyUserIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.apiKey = _data["apiKey"];
            this.destApiKey = _data["destApiKey"];
        }
    }

    static fromJS(data: any): VerifyUserIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyUserIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["apiKey"] = this.apiKey;
        data["destApiKey"] = this.destApiKey;
        return data;
    }
}

export interface IVerifyUserIdDto {
    userId: string;
    apiKey: string;
    destApiKey: string;
}

export class WebPageDetailTemplate extends DetailTemplate implements IWebPageDetailTemplate {
    loadingText?: string | undefined;
    url?: string | undefined;
    detailType!: DetailTemplateTypeEnum;

    constructor(data?: IWebPageDetailTemplate) {
        super(data);
        this._discriminator = "WebPageDetailTemplate";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.loadingText = _data["loadingText"];
            this.url = _data["url"];
            this.detailType = _data["detailType"];
        }
    }

    static override fromJS(data: any): WebPageDetailTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new WebPageDetailTemplate();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loadingText"] = this.loadingText;
        data["url"] = this.url;
        data["detailType"] = this.detailType;
        super.toJSON(data);
        return data;
    }
}

export interface IWebPageDetailTemplate extends IDetailTemplate {
    loadingText?: string | undefined;
    url?: string | undefined;
    detailType: DetailTemplateTypeEnum;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}