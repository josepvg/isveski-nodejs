/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Isveski Client
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum ActionType {
    Created = <any> 'Created',
    Updated = <any> 'Updated',
    Deleted = <any> 'Deleted'
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ActionTypeEnum {
    Nothing = <any> 'Nothing',
    ShowTicket = <any> 'ShowTicket',
    RefreshTicket = <any> 'RefreshTicket',
    RefreshTicketList = <any> 'RefreshTicketList',
    Sensor = <any> 'Sensor',
    ShowUrl = <any> 'ShowUrl',
    ShowMenu = <any> 'ShowMenu',
    ShowMessage = <any> 'ShowMessage',
    ShowMultiple = <any> 'ShowMultiple',
    ShowPrompt = <any> 'ShowPrompt',
    ShowQrCode = <any> 'ShowQrCode',
    BioAuthenticate = <any> 'BioAuthenticate',
    ListenToBeacons = <any> 'ListenToBeacons',
    NoTicket = <any> 'NoTicket',
    ShowWebPage = <any> 'ShowWebPage'
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum AuthenticationMethod {
    Bio = <any> 'Bio',
    Pin = <any> 'Pin'
}
/**
 * 
 * @export
 * @interface BaseAction
 */
export interface BaseAction {
    /**
     * 
     * @type {ActionTypeEnum}
     * @memberof BaseAction
     */
    actionType: ActionTypeEnum;
}
/**
 * 
 * @export
 * @interface BioAuthenticationRequest
 */
export interface BioAuthenticationRequest {
    /**
     * 
     * @type {string}
     * @memberof BioAuthenticationRequest
     */
    communicationId: string;
    /**
     * 
     * @type {string}
     * @memberof BioAuthenticationRequest
     */
    title: string;
    /**
     * 
     * @type {boolean}
     * @memberof BioAuthenticationRequest
     */
    allowAlternative: boolean;
    /**
     * 
     * @type {string}
     * @memberof BioAuthenticationRequest
     */
    reason: string;
    /**
     * 
     * @type {number}
     * @memberof BioAuthenticationRequest
     */
    timeoutSek: number;
}
/**
 * 
 * @export
 * @interface BioMetricAuthenticationResponse
 */
export interface BioMetricAuthenticationResponse {
    /**
     * 
     * @type {boolean}
     * @memberof BioMetricAuthenticationResponse
     */
    succeeded: boolean;
    /**
     * 
     * @type {AuthenticationMethod}
     * @memberof BioMetricAuthenticationResponse
     */
    authenticationMethod: AuthenticationMethod;
}
/**
 * 
 * @export
 * @interface Choice
 */
export interface Choice {
    /**
     * 
     * @type {number}
     * @memberof Choice
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Choice
     */
    text: string;
    /**
     * 
     * @type {boolean}
     * @memberof Choice
     */
    defaultValue: boolean;
}
/**
 * 
 * @export
 * @interface ClientTicketAction
 */
export interface ClientTicketAction {
    /**
     * 
     * @type {string}
     * @memberof ClientTicketAction
     */
    id?: string;
    /**
     * 
     * @type {ActionType}
     * @memberof ClientTicketAction
     */
    actionType?: ActionType;
    /**
     * 
     * @type {string}
     * @memberof ClientTicketAction
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientTicketAction
     */
    data?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientTicketAction
     */
    presentationData?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientTicketAction
     */
    presentationType?: string;
    /**
     * 
     * @type {Date}
     * @memberof ClientTicketAction
     */
    actionTime?: Date;
    /**
     * 
     * @type {string}
     * @memberof ClientTicketAction
     */
    note?: string;
}
/**
 * 
 * @export
 * @interface ClientWalletResponse
 */
export interface ClientWalletResponse {
    /**
     * 
     * @type {string}
     * @memberof ClientWalletResponse
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientWalletResponse
     */
    userName: string;
    /**
     * 
     * @type {string}
     * @memberof ClientWalletResponse
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientWalletResponse
     */
    phoneNumber?: string;
    /**
     * 
     * @type {Array<ClientWalletTicket>}
     * @memberof ClientWalletResponse
     */
    tickets: Array<ClientWalletTicket>;
}
/**
 * 
 * @export
 * @interface ClientWalletTicket
 */
export interface ClientWalletTicket {
    /**
     * 
     * @type {string}
     * @memberof ClientWalletTicket
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientWalletTicket
     */
    ticketDefinitionId?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientWalletTicket
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientWalletTicket
     */
    data?: string;
    /**
     * 
     * @type {Template | Template1}
     * @memberof ClientWalletTicket
     */
    template?: Template | Template1;
    /**
     * 
     * @type {DetailTemplate | DetailTemplate1 | WebPageDetailTemplate}
     * @memberof ClientWalletTicket
     */
    detailTemplate?: DetailTemplate | DetailTemplate1 | WebPageDetailTemplate;
    /**
     * 
     * @type {TicketAccess}
     * @memberof ClientWalletTicket
     */
    pushNotifications?: TicketAccess;
    /**
     * 
     * @type {TicketAccess}
     * @memberof ClientWalletTicket
     */
    beacons?: TicketAccess;
    /**
     * 
     * @type {TicketAccess}
     * @memberof ClientWalletTicket
     */
    locations?: TicketAccess;
}
/**
 * 
 * @export
 * @interface CreateTicketLogRequest
 */
export interface CreateTicketLogRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateTicketLogRequest
     */
    ticketId: string;
    /**
     * 
     * @type {LogTemplate1}
     * @memberof CreateTicketLogRequest
     */
    logTemplate: LogTemplate1;
}
/**
 * 
 * @export
 * @interface CreateTicketRequest
 */
export interface CreateTicketRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateTicketRequest
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTicketRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTicketRequest
     */
    ticketDefinitionId: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTicketRequest
     */
    data: string;
    /**
     * 
     * @type {DetailTemplate | DetailTemplate1 | WebPageDetailTemplate}
     * @memberof CreateTicketRequest
     */
    detailTemplate: DetailTemplate | DetailTemplate1 | WebPageDetailTemplate;
    /**
     * 
     * @type {Template | Template1}
     * @memberof CreateTicketRequest
     */
    template: Template | Template1;
    /**
     * 
     * @type {string}
     * @memberof CreateTicketRequest
     */
    note: string;
}
/**
 * 
 * @export
 * @interface CreateTicketResponse
 */
export interface CreateTicketResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateTicketResponse
     */
    ticketId: string;
}
/**
 * 
 * @export
 * @interface DeleteTicketRequest
 */
export interface DeleteTicketRequest {
    /**
     * 
     * @type {string}
     * @memberof DeleteTicketRequest
     */
    ticketId: string;
    /**
     * 
     * @type {string}
     * @memberof DeleteTicketRequest
     */
    note: string;
}
/**
 * 
 * @export
 * @interface DetailTemplate
 */
export interface DetailTemplate {
    /**
     * 
     * @type {DetailTemplateTypeEnum}
     * @memberof DetailTemplate
     */
    detailType: DetailTemplateTypeEnum;
}
/**
 * 
 * @export
 * @interface DetailTemplate1
 */
export interface DetailTemplate1 extends DetailTemplate {
    /**
     * 
     * @type {string}
     * @memberof DetailTemplate1
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof DetailTemplate1
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof DetailTemplate1
     */
    description?: string;
    /**
     * 
     * @type {Date}
     * @memberof DetailTemplate1
     */
    time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof DetailTemplate1
     */
    expiry?: Date;
    /**
     * 
     * @type {Array<TemplateButton>}
     * @memberof DetailTemplate1
     */
    buttons?: Array<TemplateButton>;
    /**
     * 
     * @type {DetailTemplateTypeEnum}
     * @memberof DetailTemplate1
     */
    detailType: DetailTemplateTypeEnum;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum DetailTemplateTypeEnum {
    DT1 = <any> 'DT1',
    WebPageDetailTemplate = <any> 'WebPageDetailTemplate',
    Abstract = <any> 'Abstract'
}
/**
 * 
 * @export
 * @interface DeviceException
 */
export interface DeviceException {
    /**
     * 
     * @type {StatusDetail}
     * @memberof DeviceException
     */
    statusDetail: StatusDetail;
}
/**
 * 
 * @export
 * @interface ErrorModel
 */
export interface ErrorModel {
    /**
     * 
     * @type {IceCodeErrors}
     * @memberof ErrorModel
     */
    errorCode?: IceCodeErrors;
    /**
     * 
     * @type {string}
     * @memberof ErrorModel
     */
    error?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum IceCodeErrors {
    NUMBER_1 = <any> 1,
    NUMBER_100 = <any> 100
}
/**
 * 
 * @export
 * @interface ListenToBeaconsRequest
 */
export interface ListenToBeaconsRequest {
    /**
     * 
     * @type {string}
     * @memberof ListenToBeaconsRequest
     */
    communicationId: string;
    /**
     * 
     * @type {string}
     * @memberof ListenToBeaconsRequest
     */
    ticketId: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ListenToBeaconsRequest
     */
    beacons: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ListenToBeaconsRequest
     */
    parameter: string;
    /**
     * 
     * @type {number}
     * @memberof ListenToBeaconsRequest
     */
    notifyNotFoundSek: number;
    /**
     * 
     * @type {number}
     * @memberof ListenToBeaconsRequest
     */
    timeoutSek: number;
}
/**
 * 
 * @export
 * @interface ListenToBeaconsResponse
 */
export interface ListenToBeaconsResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ListenToBeaconsResponse
     */
    succeeded: boolean;
}
/**
 * 
 * @export
 * @interface LogTemplate
 */
export interface LogTemplate {
    /**
     * 
     * @type {LogTemplateTypeEnum}
     * @memberof LogTemplate
     */
    templateType: LogTemplateTypeEnum;
}
/**
 * 
 * @export
 * @interface LogTemplate1
 */
export interface LogTemplate1 extends LogTemplate {
    /**
     * 
     * @type {string}
     * @memberof LogTemplate1
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof LogTemplate1
     */
    description?: string;
    /**
     * 
     * @type {Date}
     * @memberof LogTemplate1
     */
    time: Date;
    /**
     * 
     * @type {LogTemplateTypeEnum}
     * @memberof LogTemplate1
     */
    templateType: LogTemplateTypeEnum;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum LogTemplateTypeEnum {
    T1 = <any> 'T1'
}
/**
 * 
 * @export
 * @interface RefreshTicketAction
 */
export interface RefreshTicketAction extends BaseAction {
    /**
     * 
     * @type {string}
     * @memberof RefreshTicketAction
     */
    ticketId: string;
    /**
     * 
     * @type {ActionTypeEnum}
     * @memberof RefreshTicketAction
     */
    actionType: ActionTypeEnum;
}
/**
 * 
 * @export
 * @interface RefreshTicketListAction
 */
export interface RefreshTicketListAction extends BaseAction {
    /**
     * 
     * @type {ActionTypeEnum}
     * @memberof RefreshTicketListAction
     */
    actionType: ActionTypeEnum;
}
/**
 * 
 * @export
 * @interface ReturnChoice
 */
export interface ReturnChoice {
    /**
     * 
     * @type {number}
     * @memberof ReturnChoice
     */
    id: number;
    /**
     * 
     * @type {boolean}
     * @memberof ReturnChoice
     */
    value: boolean;
}
/**
 * 
 * @export
 * @interface SearchUserResponse
 */
export interface SearchUserResponse {
    /**
     * 
     * @type {string}
     * @memberof SearchUserResponse
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof SearchUserResponse
     */
    languageId: string;
}
/**
 * 
 * @export
 * @interface SendToTicketRequest
 */
export interface SendToTicketRequest {
    /**
     * 
     * @type {string}
     * @memberof SendToTicketRequest
     */
    ticketId: string;
    /**
     * 
     * @type {string}
     * @memberof SendToTicketRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof SendToTicketRequest
     */
    body: string;
    /**
     * 
     * @type {Array<BaseAction | SensorAction | ShowTicketAction | RefreshTicketListAction | RefreshTicketAction | ShowUrlAction>}
     * @memberof SendToTicketRequest
     */
    actions: Array<BaseAction | SensorAction | ShowTicketAction | RefreshTicketListAction | RefreshTicketAction | ShowUrlAction>;
    /**
     * 
     * @type {string}
     * @memberof SendToTicketRequest
     */
    image?: string;
    /**
     * 
     * @type {number}
     * @memberof SendToTicketRequest
     */
    priority: number;
}
/**
 * 
 * @export
 * @interface Sensor
 */
export interface Sensor {
    /**
     * 
     * @type {string}
     * @memberof Sensor
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Sensor
     */
    name?: string;
    /**
     * 
     * @type {SensorType}
     * @memberof Sensor
     */
    sensorType?: SensorType;
    /**
     * 
     * @type {string}
     * @memberof Sensor
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Sensor
     */
    enabled?: boolean;
    /**
     * 
     * @type {Array<TicketActive>}
     * @memberof Sensor
     */
    ticketsActive?: Array<TicketActive>;
}
/**
 * 
 * @export
 * @interface SensorAction
 */
export interface SensorAction extends BaseAction {
    /**
     * 
     * @type {string}
     * @memberof SensorAction
     */
    sensorId: string;
    /**
     * 
     * @type {ActionTypeEnum}
     * @memberof SensorAction
     */
    actionType: ActionTypeEnum;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum SensorType {
    Normal = <any> 'Normal',
    Push = <any> 'Push',
    Beacon = <any> 'Beacon'
}
/**
 * 
 * @export
 * @interface SensorsConfigurationResponse
 */
export interface SensorsConfigurationResponse {
    /**
     * 
     * @type {Array<Sensor>}
     * @memberof SensorsConfigurationResponse
     */
    sensors: Array<Sensor>;
}
/**
 * 
 * @export
 * @interface ShowMenuRequest
 */
export interface ShowMenuRequest {
    /**
     * 
     * @type {string}
     * @memberof ShowMenuRequest
     */
    communicationId: string;
    /**
     * 
     * @type {string}
     * @memberof ShowMenuRequest
     */
    message: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ShowMenuRequest
     */
    options: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ShowMenuRequest
     */
    timeoutSek: number;
    /**
     * 
     * @type {string}
     * @memberof ShowMenuRequest
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof ShowMenuRequest
     */
    title: string;
}
/**
 * 
 * @export
 * @interface ShowMenuResponse
 */
export interface ShowMenuResponse {
    /**
     * 
     * @type {StatusDetail}
     * @memberof ShowMenuResponse
     */
    statusDetail?: StatusDetail;
    /**
     * 
     * @type {string}
     * @memberof ShowMenuResponse
     */
    selectedValue: string;
}
/**
 * 
 * @export
 * @interface ShowMessageRequest
 */
export interface ShowMessageRequest {
    /**
     * 
     * @type {string}
     * @memberof ShowMessageRequest
     */
    communicationId: string;
    /**
     * 
     * @type {string}
     * @memberof ShowMessageRequest
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof ShowMessageRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof ShowMessageRequest
     */
    message: string;
    /**
     * 
     * @type {number}
     * @memberof ShowMessageRequest
     */
    timeoutSek: number;
    /**
     * 
     * @type {string}
     * @memberof ShowMessageRequest
     */
    close: string;
}
/**
 * 
 * @export
 * @interface ShowMultipleChoiceRequest
 */
export interface ShowMultipleChoiceRequest {
    /**
     * 
     * @type {string}
     * @memberof ShowMultipleChoiceRequest
     */
    communicationId: string;
    /**
     * 
     * @type {string}
     * @memberof ShowMultipleChoiceRequest
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ShowMultipleChoiceRequest
     */
    closeText: string;
    /**
     * 
     * @type {Array<Choice>}
     * @memberof ShowMultipleChoiceRequest
     */
    options: Array<Choice>;
    /**
     * 
     * @type {number}
     * @memberof ShowMultipleChoiceRequest
     */
    timeoutSek: number;
    /**
     * 
     * @type {string}
     * @memberof ShowMultipleChoiceRequest
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof ShowMultipleChoiceRequest
     */
    title?: string;
}
/**
 * 
 * @export
 * @interface ShowMultipleChoiceResponse
 */
export interface ShowMultipleChoiceResponse {
    /**
     * 
     * @type {StatusDetail}
     * @memberof ShowMultipleChoiceResponse
     */
    statusDetail?: StatusDetail;
    /**
     * 
     * @type {Array<ReturnChoice>}
     * @memberof ShowMultipleChoiceResponse
     */
    choices: Array<ReturnChoice>;
}
/**
 * 
 * @export
 * @interface ShowPromptRequest
 */
export interface ShowPromptRequest {
    /**
     * 
     * @type {string}
     * @memberof ShowPromptRequest
     */
    communicationId: string;
    /**
     * 
     * @type {string}
     * @memberof ShowPromptRequest
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof ShowPromptRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof ShowPromptRequest
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ShowPromptRequest
     */
    yes: string;
    /**
     * 
     * @type {string}
     * @memberof ShowPromptRequest
     */
    no: string;
    /**
     * 
     * @type {number}
     * @memberof ShowPromptRequest
     */
    timeoutSek: number;
}
/**
 * 
 * @export
 * @interface ShowPromptResponse
 */
export interface ShowPromptResponse {
    /**
     * 
     * @type {StatusDetail}
     * @memberof ShowPromptResponse
     */
    statusDetail?: StatusDetail;
    /**
     * 
     * @type {boolean}
     * @memberof ShowPromptResponse
     */
    result: boolean;
    /**
     * 
     * @type {string}
     * @memberof ShowPromptResponse
     */
    extra?: string;
}
/**
 * 
 * @export
 * @interface ShowQrCodeRequest
 */
export interface ShowQrCodeRequest {
    /**
     * 
     * @type {string}
     * @memberof ShowQrCodeRequest
     */
    communicationId: string;
    /**
     * 
     * @type {string}
     * @memberof ShowQrCodeRequest
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ShowQrCodeRequest
     */
    qrCode: string;
    /**
     * 
     * @type {number}
     * @memberof ShowQrCodeRequest
     */
    timeoutSek: number;
    /**
     * 
     * @type {string}
     * @memberof ShowQrCodeRequest
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof ShowQrCodeRequest
     */
    title: string;
}
/**
 * 
 * @export
 * @interface ShowTicketAction
 */
export interface ShowTicketAction extends BaseAction {
    /**
     * 
     * @type {string}
     * @memberof ShowTicketAction
     */
    ticketId: string;
    /**
     * 
     * @type {ActionTypeEnum}
     * @memberof ShowTicketAction
     */
    actionType: ActionTypeEnum;
}
/**
 * 
 * @export
 * @interface ShowUrlAction
 */
export interface ShowUrlAction extends BaseAction {
    /**
     * 
     * @type {string}
     * @memberof ShowUrlAction
     */
    url: string;
    /**
     * 
     * @type {ActionTypeEnum}
     * @memberof ShowUrlAction
     */
    actionType: ActionTypeEnum;
}
/**
 * 
 * @export
 * @interface ShowWebPageRequest
 */
export interface ShowWebPageRequest {
    /**
     * 
     * @type {string}
     * @memberof ShowWebPageRequest
     */
    communicationId: string;
    /**
     * 
     * @type {string}
     * @memberof ShowWebPageRequest
     */
    loadingText: string;
    /**
     * 
     * @type {string}
     * @memberof ShowWebPageRequest
     */
    url: string;
    /**
     * 
     * @type {number}
     * @memberof ShowWebPageRequest
     */
    timeoutSek: number;
}
/**
 * 
 * @export
 * @interface ShowWebPageResponse
 */
export interface ShowWebPageResponse {
    /**
     * 
     * @type {StatusDetail}
     * @memberof ShowWebPageResponse
     */
    statusDetail?: StatusDetail;
    /**
     * 
     * @type {string}
     * @memberof ShowWebPageResponse
     */
    result: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum StatusDetail {
    Success = <any> 'Success',
    Timeout = <any> 'Timeout',
    Cancelled = <any> 'Cancelled'
}
/**
 * 
 * @export
 * @interface Template
 */
export interface Template {
    /**
     * 
     * @type {TemplateTypeEnum}
     * @memberof Template
     */
    templateType: TemplateTypeEnum;
}
/**
 * 
 * @export
 * @interface Template1
 */
export interface Template1 extends Template {
    /**
     * 
     * @type {string}
     * @memberof Template1
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof Template1
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof Template1
     */
    description?: string;
    /**
     * 
     * @type {Date}
     * @memberof Template1
     */
    time?: Date;
    /**
     * 
     * @type {Date}
     * @memberof Template1
     */
    expiry?: Date;
    /**
     * 
     * @type {TemplateTypeEnum}
     * @memberof Template1
     */
    templateType: TemplateTypeEnum;
}
/**
 * 
 * @export
 * @interface TemplateButton
 */
export interface TemplateButton {
    /**
     * 
     * @type {string}
     * @memberof TemplateButton
     */
    text: string;
    /**
     * 
     * @type {BaseAction | SensorAction | ShowTicketAction | RefreshTicketListAction | RefreshTicketAction | ShowUrlAction}
     * @memberof TemplateButton
     */
    action: BaseAction | SensorAction | ShowTicketAction | RefreshTicketListAction | RefreshTicketAction | ShowUrlAction;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum TemplateTypeEnum {
    T1 = <any> 'T1',
    Abstract = <any> 'Abstract'
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum TicketAccess {
    NUMBER_0 = <any> 0,
    NUMBER_1 = <any> 1,
    NUMBER_2 = <any> 2,
    NUMBER_3 = <any> 3
}
/**
 * 
 * @export
 * @interface TicketActive
 */
export interface TicketActive {
    /**
     * 
     * @type {string}
     * @memberof TicketActive
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketActive
     */
    ticketName?: string;
}
/**
 * 
 * @export
 * @interface TicketConfigurationResponse
 */
export interface TicketConfigurationResponse {
    /**
     * 
     * @type {Array<TicketDefinition>}
     * @memberof TicketConfigurationResponse
     */
    ticketDefinitions?: Array<TicketDefinition>;
}
/**
 * 
 * @export
 * @interface TicketDefinition
 */
export interface TicketDefinition {
    /**
     * 
     * @type {string}
     * @memberof TicketDefinition
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TicketDefinition
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface UpdateTicketRequest
 */
export interface UpdateTicketRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateTicketRequest
     */
    ticketId: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTicketRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTicketRequest
     */
    data: string;
    /**
     * 
     * @type {Template | Template1}
     * @memberof UpdateTicketRequest
     */
    template: Template | Template1;
    /**
     * 
     * @type {DetailTemplate | DetailTemplate1 | WebPageDetailTemplate}
     * @memberof UpdateTicketRequest
     */
    detailTemplate: DetailTemplate | DetailTemplate1 | WebPageDetailTemplate;
    /**
     * 
     * @type {string}
     * @memberof UpdateTicketRequest
     */
    note: string;
}
/**
 * 
 * @export
 * @interface VerifyCredentialsResult
 */
export interface VerifyCredentialsResult {
    /**
     * 
     * @type {string}
     * @memberof VerifyCredentialsResult
     */
    clientUri: string;
    /**
     * 
     * @type {string}
     * @memberof VerifyCredentialsResult
     */
    clientName: string;
}
/**
 * 
 * @export
 * @interface VerifyCredentialsUserIdResult
 */
export interface VerifyCredentialsUserIdResult {
    /**
     * 
     * @type {string}
     * @memberof VerifyCredentialsUserIdResult
     */
    clientUri: string;
    /**
     * 
     * @type {string}
     * @memberof VerifyCredentialsUserIdResult
     */
    userName: string;
    /**
     * 
     * @type {string}
     * @memberof VerifyCredentialsUserIdResult
     */
    clientName: string;
}
/**
 * 
 * @export
 * @interface VerifyDto
 */
export interface VerifyDto {
    /**
     * 
     * @type {string}
     * @memberof VerifyDto
     */
    userName: string;
    /**
     * 
     * @type {string}
     * @memberof VerifyDto
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof VerifyDto
     */
    apiKey: string;
    /**
     * 
     * @type {string}
     * @memberof VerifyDto
     */
    destApiKey: string;
}
/**
 * 
 * @export
 * @interface VerifyUserIdDto
 */
export interface VerifyUserIdDto {
    /**
     * 
     * @type {string}
     * @memberof VerifyUserIdDto
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof VerifyUserIdDto
     */
    apiKey: string;
    /**
     * 
     * @type {string}
     * @memberof VerifyUserIdDto
     */
    destApiKey: string;
}
/**
 * 
 * @export
 * @interface WebPageDetailTemplate
 */
export interface WebPageDetailTemplate extends DetailTemplate {
    /**
     * 
     * @type {string}
     * @memberof WebPageDetailTemplate
     */
    loadingText?: string;
    /**
     * 
     * @type {string}
     * @memberof WebPageDetailTemplate
     */
    url?: string;
    /**
     * 
     * @type {DetailTemplateTypeEnum}
     * @memberof WebPageDetailTemplate
     */
    detailType: DetailTemplateTypeEnum;
}
/**
 * ClientDeviceInterfaceApi - fetch parameter creator
 * @export
 */
export const ClientDeviceInterfaceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Uses the devices authentication mechanism, e.g. fingerprint or face recognision to authenticate the user
         * @summary Bioauthenticates the user
         * @param {BioAuthenticationRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bioAuthenticate(body: BioAuthenticationRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling bioAuthenticate.');
            }
            const localVarPath = `/api/ClientDeviceInterface/BioAuthenticate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BioAuthenticationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts listening to beacons and sends to the clients endpoint
         * @summary Listens to beacons in the surroundings
         * @param {ListenToBeaconsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listenToBeacons(body: ListenToBeaconsRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling listenToBeacons.');
            }
            const localVarPath = `/api/ClientDeviceInterface/ListenToBeacons`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ListenToBeaconsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Shows a menu in the app where users can select between the options
         * @summary Shows a menu
         * @param {ShowMenuRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showMenu(body: ShowMenuRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling showMenu.');
            }
            const localVarPath = `/api/ClientDeviceInterface/ShowMenu`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ShowMenuRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Shows a message in the isveski app
         * @summary Shows a message
         * @param {ShowMessageRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showMessage(body: ShowMessageRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling showMessage.');
            }
            const localVarPath = `/api/ClientDeviceInterface/ShowMessage`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ShowMessageRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Shows a multiple choice menu in the app where the user can select 0 or many of the options
         * @summary Shows multiple choices
         * @param {ShowMultipleChoiceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showMultipleChoice(body: ShowMultipleChoiceRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling showMultipleChoice.');
            }
            const localVarPath = `/api/ClientDeviceInterface/ShowMultipleChoice`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ShowMultipleChoiceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Shows a prompt in the app where the user can press between 2 buttons
         * @summary Shows a prompt
         * @param {ShowPromptRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPrompt(body: ShowPromptRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling showPrompt.');
            }
            const localVarPath = `/api/ClientDeviceInterface/ShowPrompt`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ShowPromptRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Shows the Qr Code in the app
         * @summary Shows Qr Code
         * @param {ShowQrCodeRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showQrCode(body: ShowQrCodeRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling showQrCode.');
            }
            const localVarPath = `/api/ClientDeviceInterface/ShowQrCode`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ShowQrCodeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This action is not completed
         * @summary Shows a webpage inside the app, passing the user as a cookie
         * @param {ShowWebPageRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showWebPage(body: ShowWebPageRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling showWebPage.');
            }
            const localVarPath = `/api/ClientDeviceInterface/ShowWebPage`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ShowWebPageRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientDeviceInterfaceApi - functional programming interface
 * @export
 */
export const ClientDeviceInterfaceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Uses the devices authentication mechanism, e.g. fingerprint or face recognision to authenticate the user
         * @summary Bioauthenticates the user
         * @param {BioAuthenticationRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bioAuthenticate(body: BioAuthenticationRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BioMetricAuthenticationResponse> {
            const localVarFetchArgs = ClientDeviceInterfaceApiFetchParamCreator(configuration).bioAuthenticate(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Starts listening to beacons and sends to the clients endpoint
         * @summary Listens to beacons in the surroundings
         * @param {ListenToBeaconsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listenToBeacons(body: ListenToBeaconsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListenToBeaconsResponse> {
            const localVarFetchArgs = ClientDeviceInterfaceApiFetchParamCreator(configuration).listenToBeacons(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Shows a menu in the app where users can select between the options
         * @summary Shows a menu
         * @param {ShowMenuRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showMenu(body: ShowMenuRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ShowMenuResponse> {
            const localVarFetchArgs = ClientDeviceInterfaceApiFetchParamCreator(configuration).showMenu(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Shows a message in the isveski app
         * @summary Shows a message
         * @param {ShowMessageRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showMessage(body: ShowMessageRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ClientDeviceInterfaceApiFetchParamCreator(configuration).showMessage(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Shows a multiple choice menu in the app where the user can select 0 or many of the options
         * @summary Shows multiple choices
         * @param {ShowMultipleChoiceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showMultipleChoice(body: ShowMultipleChoiceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ShowMultipleChoiceResponse> {
            const localVarFetchArgs = ClientDeviceInterfaceApiFetchParamCreator(configuration).showMultipleChoice(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Shows a prompt in the app where the user can press between 2 buttons
         * @summary Shows a prompt
         * @param {ShowPromptRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPrompt(body: ShowPromptRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ShowPromptResponse> {
            const localVarFetchArgs = ClientDeviceInterfaceApiFetchParamCreator(configuration).showPrompt(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Shows the Qr Code in the app
         * @summary Shows Qr Code
         * @param {ShowQrCodeRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showQrCode(body: ShowQrCodeRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ClientDeviceInterfaceApiFetchParamCreator(configuration).showQrCode(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This action is not completed
         * @summary Shows a webpage inside the app, passing the user as a cookie
         * @param {ShowWebPageRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showWebPage(body: ShowWebPageRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ShowWebPageResponse> {
            const localVarFetchArgs = ClientDeviceInterfaceApiFetchParamCreator(configuration).showWebPage(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ClientDeviceInterfaceApi - factory interface
 * @export
 */
export const ClientDeviceInterfaceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Uses the devices authentication mechanism, e.g. fingerprint or face recognision to authenticate the user
         * @summary Bioauthenticates the user
         * @param {BioAuthenticationRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bioAuthenticate(body: BioAuthenticationRequest, options?: any) {
            return ClientDeviceInterfaceApiFp(configuration).bioAuthenticate(body, options)(fetch, basePath);
        },
        /**
         * Starts listening to beacons and sends to the clients endpoint
         * @summary Listens to beacons in the surroundings
         * @param {ListenToBeaconsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listenToBeacons(body: ListenToBeaconsRequest, options?: any) {
            return ClientDeviceInterfaceApiFp(configuration).listenToBeacons(body, options)(fetch, basePath);
        },
        /**
         * Shows a menu in the app where users can select between the options
         * @summary Shows a menu
         * @param {ShowMenuRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showMenu(body: ShowMenuRequest, options?: any) {
            return ClientDeviceInterfaceApiFp(configuration).showMenu(body, options)(fetch, basePath);
        },
        /**
         * Shows a message in the isveski app
         * @summary Shows a message
         * @param {ShowMessageRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showMessage(body: ShowMessageRequest, options?: any) {
            return ClientDeviceInterfaceApiFp(configuration).showMessage(body, options)(fetch, basePath);
        },
        /**
         * Shows a multiple choice menu in the app where the user can select 0 or many of the options
         * @summary Shows multiple choices
         * @param {ShowMultipleChoiceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showMultipleChoice(body: ShowMultipleChoiceRequest, options?: any) {
            return ClientDeviceInterfaceApiFp(configuration).showMultipleChoice(body, options)(fetch, basePath);
        },
        /**
         * Shows a prompt in the app where the user can press between 2 buttons
         * @summary Shows a prompt
         * @param {ShowPromptRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showPrompt(body: ShowPromptRequest, options?: any) {
            return ClientDeviceInterfaceApiFp(configuration).showPrompt(body, options)(fetch, basePath);
        },
        /**
         * Shows the Qr Code in the app
         * @summary Shows Qr Code
         * @param {ShowQrCodeRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showQrCode(body: ShowQrCodeRequest, options?: any) {
            return ClientDeviceInterfaceApiFp(configuration).showQrCode(body, options)(fetch, basePath);
        },
        /**
         * This action is not completed
         * @summary Shows a webpage inside the app, passing the user as a cookie
         * @param {ShowWebPageRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        showWebPage(body: ShowWebPageRequest, options?: any) {
            return ClientDeviceInterfaceApiFp(configuration).showWebPage(body, options)(fetch, basePath);
        },
    };
};

/**
 * ClientDeviceInterfaceApi - object-oriented interface
 * @export
 * @class ClientDeviceInterfaceApi
 * @extends {BaseAPI}
 */
export class ClientDeviceInterfaceApi extends BaseAPI {
    /**
     * Uses the devices authentication mechanism, e.g. fingerprint or face recognision to authenticate the user
     * @summary Bioauthenticates the user
     * @param {BioAuthenticationRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientDeviceInterfaceApi
     */
    public bioAuthenticate(body: BioAuthenticationRequest, options?: any) {
        return ClientDeviceInterfaceApiFp(this.configuration).bioAuthenticate(body, options)(this.fetch, this.basePath);
    }

    /**
     * Starts listening to beacons and sends to the clients endpoint
     * @summary Listens to beacons in the surroundings
     * @param {ListenToBeaconsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientDeviceInterfaceApi
     */
    public listenToBeacons(body: ListenToBeaconsRequest, options?: any) {
        return ClientDeviceInterfaceApiFp(this.configuration).listenToBeacons(body, options)(this.fetch, this.basePath);
    }

    /**
     * Shows a menu in the app where users can select between the options
     * @summary Shows a menu
     * @param {ShowMenuRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientDeviceInterfaceApi
     */
    public showMenu(body: ShowMenuRequest, options?: any) {
        return ClientDeviceInterfaceApiFp(this.configuration).showMenu(body, options)(this.fetch, this.basePath);
    }

    /**
     * Shows a message in the isveski app
     * @summary Shows a message
     * @param {ShowMessageRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientDeviceInterfaceApi
     */
    public showMessage(body: ShowMessageRequest, options?: any) {
        return ClientDeviceInterfaceApiFp(this.configuration).showMessage(body, options)(this.fetch, this.basePath);
    }

    /**
     * Shows a multiple choice menu in the app where the user can select 0 or many of the options
     * @summary Shows multiple choices
     * @param {ShowMultipleChoiceRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientDeviceInterfaceApi
     */
    public showMultipleChoice(body: ShowMultipleChoiceRequest, options?: any) {
        return ClientDeviceInterfaceApiFp(this.configuration).showMultipleChoice(body, options)(this.fetch, this.basePath);
    }

    /**
     * Shows a prompt in the app where the user can press between 2 buttons
     * @summary Shows a prompt
     * @param {ShowPromptRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientDeviceInterfaceApi
     */
    public showPrompt(body: ShowPromptRequest, options?: any) {
        return ClientDeviceInterfaceApiFp(this.configuration).showPrompt(body, options)(this.fetch, this.basePath);
    }

    /**
     * Shows the Qr Code in the app
     * @summary Shows Qr Code
     * @param {ShowQrCodeRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientDeviceInterfaceApi
     */
    public showQrCode(body: ShowQrCodeRequest, options?: any) {
        return ClientDeviceInterfaceApiFp(this.configuration).showQrCode(body, options)(this.fetch, this.basePath);
    }

    /**
     * This action is not completed
     * @summary Shows a webpage inside the app, passing the user as a cookie
     * @param {ShowWebPageRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientDeviceInterfaceApi
     */
    public showWebPage(body: ShowWebPageRequest, options?: any) {
        return ClientDeviceInterfaceApiFp(this.configuration).showWebPage(body, options)(this.fetch, this.basePath);
    }

}
/**
 * ClientSensorsApi - fetch parameter creator
 * @export
 */
export const ClientSensorsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets the list of sensors belonging to this client
         * @summary Gets the list of sensors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfSensors(options: any = {}): FetchArgs {
            const localVarPath = `/api/ClientSensors/GetListOfSensors`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientSensorsApi - functional programming interface
 * @export
 */
export const ClientSensorsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Gets the list of sensors belonging to this client
         * @summary Gets the list of sensors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfSensors(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SensorsConfigurationResponse> {
            const localVarFetchArgs = ClientSensorsApiFetchParamCreator(configuration).getListOfSensors(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ClientSensorsApi - factory interface
 * @export
 */
export const ClientSensorsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Gets the list of sensors belonging to this client
         * @summary Gets the list of sensors
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfSensors(options?: any) {
            return ClientSensorsApiFp(configuration).getListOfSensors(options)(fetch, basePath);
        },
    };
};

/**
 * ClientSensorsApi - object-oriented interface
 * @export
 * @class ClientSensorsApi
 * @extends {BaseAPI}
 */
export class ClientSensorsApi extends BaseAPI {
    /**
     * Gets the list of sensors belonging to this client
     * @summary Gets the list of sensors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientSensorsApi
     */
    public getListOfSensors(options?: any) {
        return ClientSensorsApiFp(this.configuration).getListOfSensors(options)(this.fetch, this.basePath);
    }

}
/**
 * ClientTicketDefinitionsApi - fetch parameter creator
 * @export
 */
export const ClientTicketDefinitionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets the list of ticket definitions belonging to this client
         * @summary Gets the list of ticket definitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfTicketDefinitions(options: any = {}): FetchArgs {
            const localVarPath = `/api/ClientTicketDefinitions/GetListOfTicketDefinitions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientTicketDefinitionsApi - functional programming interface
 * @export
 */
export const ClientTicketDefinitionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Gets the list of ticket definitions belonging to this client
         * @summary Gets the list of ticket definitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfTicketDefinitions(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TicketConfigurationResponse> {
            const localVarFetchArgs = ClientTicketDefinitionsApiFetchParamCreator(configuration).getListOfTicketDefinitions(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ClientTicketDefinitionsApi - factory interface
 * @export
 */
export const ClientTicketDefinitionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Gets the list of ticket definitions belonging to this client
         * @summary Gets the list of ticket definitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getListOfTicketDefinitions(options?: any) {
            return ClientTicketDefinitionsApiFp(configuration).getListOfTicketDefinitions(options)(fetch, basePath);
        },
    };
};

/**
 * ClientTicketDefinitionsApi - object-oriented interface
 * @export
 * @class ClientTicketDefinitionsApi
 * @extends {BaseAPI}
 */
export class ClientTicketDefinitionsApi extends BaseAPI {
    /**
     * Gets the list of ticket definitions belonging to this client
     * @summary Gets the list of ticket definitions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientTicketDefinitionsApi
     */
    public getListOfTicketDefinitions(options?: any) {
        return ClientTicketDefinitionsApiFp(this.configuration).getListOfTicketDefinitions(options)(this.fetch, this.basePath);
    }

}
/**
 * ClientWalletApi - fetch parameter creator
 * @export
 */
export const ClientWalletApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a ticket in the users wallet and sends a push notification of that event
         * @summary Creates a ticket in the users wallet
         * @param {CreateTicketRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicket(body: CreateTicketRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createTicket.');
            }
            const localVarPath = `/api/ClientWallet/CreateTicket`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateTicketRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a ticket log for the specified ticket
         * @summary Creates a ticket log
         * @param {CreateTicketLogRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicketLog(body: CreateTicketLogRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createTicketLog.');
            }
            const localVarPath = `/api/ClientWallet/CreateTicketLog`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateTicketLogRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes the specified ticket from the users wallet
         * @summary Deletes the ticket
         * @param {DeleteTicketRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTicket(body: DeleteTicketRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling deleteTicket.');
            }
            const localVarPath = `/api/ClientWallet/DeleteTicket`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeleteTicketRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the list of actions that have been performed on this ticket
         * @summary Gets the actions belongint to this ticket
         * @param {string} ticketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketActions(ticketId: string, options: any = {}): FetchArgs {
            // verify required parameter 'ticketId' is not null or undefined
            if (ticketId === null || ticketId === undefined) {
                throw new RequiredError('ticketId','Required parameter ticketId was null or undefined when calling getTicketActions.');
            }
            const localVarPath = `/api/ClientWallet/GetTicketActions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (ticketId !== undefined) {
                localVarQueryParameter['ticketId'] = ticketId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the ticket specified by the id, the data, templates and name
         * @summary Gets the ticket specified by the id
         * @param {string} ticketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketById(ticketId: string, options: any = {}): FetchArgs {
            // verify required parameter 'ticketId' is not null or undefined
            if (ticketId === null || ticketId === undefined) {
                throw new RequiredError('ticketId','Required parameter ticketId was null or undefined when calling getTicketById.');
            }
            const localVarPath = `/api/ClientWallet/GetTicketById`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (ticketId !== undefined) {
                localVarQueryParameter['ticketId'] = ticketId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the users wallet but only the tickets accessible for this client
         * @summary Gets the users wallet
         * @param {string} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletByClient(userid: string, options: any = {}): FetchArgs {
            // verify required parameter 'userid' is not null or undefined
            if (userid === null || userid === undefined) {
                throw new RequiredError('userid','Required parameter userid was null or undefined when calling getWalletByClient.');
            }
            const localVarPath = `/api/ClientWallet/GetWalletByClient`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (userid !== undefined) {
                localVarQueryParameter['userid'] = userid;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches the user by user name, returning the user id
         * @summary Searches the user by username
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUser(username: string, options: any = {}): FetchArgs {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling searchUser.');
            }
            const localVarPath = `/api/ClientWallet/SearchUser`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the specified ticket, replacing it with the new data and templates
         * @summary Updates the ticket
         * @param {UpdateTicketRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTicket(body: UpdateTicketRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateTicket.');
            }
            const localVarPath = `/api/ClientWallet/UpdateTicket`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateTicketRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientWalletApi - functional programming interface
 * @export
 */
export const ClientWalletApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a ticket in the users wallet and sends a push notification of that event
         * @summary Creates a ticket in the users wallet
         * @param {CreateTicketRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicket(body: CreateTicketRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateTicketResponse> {
            const localVarFetchArgs = ClientWalletApiFetchParamCreator(configuration).createTicket(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a ticket log for the specified ticket
         * @summary Creates a ticket log
         * @param {CreateTicketLogRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicketLog(body: CreateTicketLogRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = ClientWalletApiFetchParamCreator(configuration).createTicketLog(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes the specified ticket from the users wallet
         * @summary Deletes the ticket
         * @param {DeleteTicketRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTicket(body: DeleteTicketRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ClientWalletApiFetchParamCreator(configuration).deleteTicket(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets the list of actions that have been performed on this ticket
         * @summary Gets the actions belongint to this ticket
         * @param {string} ticketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketActions(ticketId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ClientTicketAction>> {
            const localVarFetchArgs = ClientWalletApiFetchParamCreator(configuration).getTicketActions(ticketId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets the ticket specified by the id, the data, templates and name
         * @summary Gets the ticket specified by the id
         * @param {string} ticketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketById(ticketId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ClientWalletTicket> {
            const localVarFetchArgs = ClientWalletApiFetchParamCreator(configuration).getTicketById(ticketId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets the users wallet but only the tickets accessible for this client
         * @summary Gets the users wallet
         * @param {string} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletByClient(userid: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ClientWalletResponse> {
            const localVarFetchArgs = ClientWalletApiFetchParamCreator(configuration).getWalletByClient(userid, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Searches the user by user name, returning the user id
         * @summary Searches the user by username
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUser(username: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SearchUserResponse> {
            const localVarFetchArgs = ClientWalletApiFetchParamCreator(configuration).searchUser(username, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates the specified ticket, replacing it with the new data and templates
         * @summary Updates the ticket
         * @param {UpdateTicketRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTicket(body: UpdateTicketRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ClientWalletApiFetchParamCreator(configuration).updateTicket(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ClientWalletApi - factory interface
 * @export
 */
export const ClientWalletApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a ticket in the users wallet and sends a push notification of that event
         * @summary Creates a ticket in the users wallet
         * @param {CreateTicketRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicket(body: CreateTicketRequest, options?: any) {
            return ClientWalletApiFp(configuration).createTicket(body, options)(fetch, basePath);
        },
        /**
         * Creates a ticket log for the specified ticket
         * @summary Creates a ticket log
         * @param {CreateTicketLogRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicketLog(body: CreateTicketLogRequest, options?: any) {
            return ClientWalletApiFp(configuration).createTicketLog(body, options)(fetch, basePath);
        },
        /**
         * Deletes the specified ticket from the users wallet
         * @summary Deletes the ticket
         * @param {DeleteTicketRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTicket(body: DeleteTicketRequest, options?: any) {
            return ClientWalletApiFp(configuration).deleteTicket(body, options)(fetch, basePath);
        },
        /**
         * Gets the list of actions that have been performed on this ticket
         * @summary Gets the actions belongint to this ticket
         * @param {string} ticketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketActions(ticketId: string, options?: any) {
            return ClientWalletApiFp(configuration).getTicketActions(ticketId, options)(fetch, basePath);
        },
        /**
         * Gets the ticket specified by the id, the data, templates and name
         * @summary Gets the ticket specified by the id
         * @param {string} ticketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketById(ticketId: string, options?: any) {
            return ClientWalletApiFp(configuration).getTicketById(ticketId, options)(fetch, basePath);
        },
        /**
         * Gets the users wallet but only the tickets accessible for this client
         * @summary Gets the users wallet
         * @param {string} userid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWalletByClient(userid: string, options?: any) {
            return ClientWalletApiFp(configuration).getWalletByClient(userid, options)(fetch, basePath);
        },
        /**
         * Searches the user by user name, returning the user id
         * @summary Searches the user by username
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUser(username: string, options?: any) {
            return ClientWalletApiFp(configuration).searchUser(username, options)(fetch, basePath);
        },
        /**
         * Updates the specified ticket, replacing it with the new data and templates
         * @summary Updates the ticket
         * @param {UpdateTicketRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTicket(body: UpdateTicketRequest, options?: any) {
            return ClientWalletApiFp(configuration).updateTicket(body, options)(fetch, basePath);
        },
    };
};

/**
 * ClientWalletApi - object-oriented interface
 * @export
 * @class ClientWalletApi
 * @extends {BaseAPI}
 */
export class ClientWalletApi extends BaseAPI {
    /**
     * Creates a ticket in the users wallet and sends a push notification of that event
     * @summary Creates a ticket in the users wallet
     * @param {CreateTicketRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientWalletApi
     */
    public createTicket(body: CreateTicketRequest, options?: any) {
        return ClientWalletApiFp(this.configuration).createTicket(body, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a ticket log for the specified ticket
     * @summary Creates a ticket log
     * @param {CreateTicketLogRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientWalletApi
     */
    public createTicketLog(body: CreateTicketLogRequest, options?: any) {
        return ClientWalletApiFp(this.configuration).createTicketLog(body, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes the specified ticket from the users wallet
     * @summary Deletes the ticket
     * @param {DeleteTicketRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientWalletApi
     */
    public deleteTicket(body: DeleteTicketRequest, options?: any) {
        return ClientWalletApiFp(this.configuration).deleteTicket(body, options)(this.fetch, this.basePath);
    }

    /**
     * Gets the list of actions that have been performed on this ticket
     * @summary Gets the actions belongint to this ticket
     * @param {string} ticketId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientWalletApi
     */
    public getTicketActions(ticketId: string, options?: any) {
        return ClientWalletApiFp(this.configuration).getTicketActions(ticketId, options)(this.fetch, this.basePath);
    }

    /**
     * Gets the ticket specified by the id, the data, templates and name
     * @summary Gets the ticket specified by the id
     * @param {string} ticketId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientWalletApi
     */
    public getTicketById(ticketId: string, options?: any) {
        return ClientWalletApiFp(this.configuration).getTicketById(ticketId, options)(this.fetch, this.basePath);
    }

    /**
     * Gets the users wallet but only the tickets accessible for this client
     * @summary Gets the users wallet
     * @param {string} userid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientWalletApi
     */
    public getWalletByClient(userid: string, options?: any) {
        return ClientWalletApiFp(this.configuration).getWalletByClient(userid, options)(this.fetch, this.basePath);
    }

    /**
     * Searches the user by user name, returning the user id
     * @summary Searches the user by username
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientWalletApi
     */
    public searchUser(username: string, options?: any) {
        return ClientWalletApiFp(this.configuration).searchUser(username, options)(this.fetch, this.basePath);
    }

    /**
     * Updates the specified ticket, replacing it with the new data and templates
     * @summary Updates the ticket
     * @param {UpdateTicketRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientWalletApi
     */
    public updateTicket(body: UpdateTicketRequest, options?: any) {
        return ClientWalletApiFp(this.configuration).updateTicket(body, options)(this.fetch, this.basePath);
    }

}
/**
 * DemoApi - fetch parameter creator
 * @export
 */
export const DemoApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Verifies the credentials but only for the user id
         * @summary Verifies the credentials for the playground
         * @param {VerifyUserIdDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifiesTheCredentials(body: VerifyUserIdDto, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling verifiesTheCredentials.');
            }
            const localVarPath = `/api/Demo/VerifyCredentialsUserId`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VerifyUserIdDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies the credentials for the playground part
         * @summary Verifies the credentials for the playground
         * @param {VerifyDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCredentials(body: VerifyDto, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling verifyCredentials.');
            }
            const localVarPath = `/api/Demo/VerifyCredentials`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VerifyDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DemoApi - functional programming interface
 * @export
 */
export const DemoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Verifies the credentials but only for the user id
         * @summary Verifies the credentials for the playground
         * @param {VerifyUserIdDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifiesTheCredentials(body: VerifyUserIdDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VerifyCredentialsUserIdResult> {
            const localVarFetchArgs = DemoApiFetchParamCreator(configuration).verifiesTheCredentials(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Verifies the credentials for the playground part
         * @summary Verifies the credentials for the playground
         * @param {VerifyDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCredentials(body: VerifyDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VerifyCredentialsResult> {
            const localVarFetchArgs = DemoApiFetchParamCreator(configuration).verifyCredentials(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DemoApi - factory interface
 * @export
 */
export const DemoApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Verifies the credentials but only for the user id
         * @summary Verifies the credentials for the playground
         * @param {VerifyUserIdDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifiesTheCredentials(body: VerifyUserIdDto, options?: any) {
            return DemoApiFp(configuration).verifiesTheCredentials(body, options)(fetch, basePath);
        },
        /**
         * Verifies the credentials for the playground part
         * @summary Verifies the credentials for the playground
         * @param {VerifyDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCredentials(body: VerifyDto, options?: any) {
            return DemoApiFp(configuration).verifyCredentials(body, options)(fetch, basePath);
        },
    };
};

/**
 * DemoApi - object-oriented interface
 * @export
 * @class DemoApi
 * @extends {BaseAPI}
 */
export class DemoApi extends BaseAPI {
    /**
     * Verifies the credentials but only for the user id
     * @summary Verifies the credentials for the playground
     * @param {VerifyUserIdDto} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemoApi
     */
    public verifiesTheCredentials(body: VerifyUserIdDto, options?: any) {
        return DemoApiFp(this.configuration).verifiesTheCredentials(body, options)(this.fetch, this.basePath);
    }

    /**
     * Verifies the credentials for the playground part
     * @summary Verifies the credentials for the playground
     * @param {VerifyDto} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DemoApi
     */
    public verifyCredentials(body: VerifyDto, options?: any) {
        return DemoApiFp(this.configuration).verifyCredentials(body, options)(this.fetch, this.basePath);
    }

}
/**
 * PushNotificationsApi - fetch parameter creator
 * @export
 */
export const PushNotificationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SendToTicketRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendToTicket(body: SendToTicketRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sendToTicket.');
            }
            const localVarPath = `/api/PushNotifications/SendToTicket`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("x-api-key")
					: configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SendToTicketRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PushNotificationsApi - functional programming interface
 * @export
 */
export const PushNotificationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SendToTicketRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendToTicket(body: SendToTicketRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = PushNotificationsApiFetchParamCreator(configuration).sendToTicket(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PushNotificationsApi - factory interface
 * @export
 */
export const PushNotificationsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {SendToTicketRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendToTicket(body: SendToTicketRequest, options?: any) {
            return PushNotificationsApiFp(configuration).sendToTicket(body, options)(fetch, basePath);
        },
    };
};

/**
 * PushNotificationsApi - object-oriented interface
 * @export
 * @class PushNotificationsApi
 * @extends {BaseAPI}
 */
export class PushNotificationsApi extends BaseAPI {
    /**
     * 
     * @param {SendToTicketRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushNotificationsApi
     */
    public sendToTicket(body: SendToTicketRequest, options?: any) {
        return PushNotificationsApiFp(this.configuration).sendToTicket(body, options)(this.fetch, this.basePath);
    }

}
